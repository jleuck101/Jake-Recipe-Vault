<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Jake's Recipe Book</title>
  <meta name="theme-color" content="#0b0c10" />
  <style>
    :root{
      --bg:#0b0c10;
      --panel:#12141b;
      --panel2:#171a23;
      --text:#eef2ff;
      --muted:rgba(238,242,255,.72);
      --line:rgba(255,255,255,.12);
      --accent:#7c3aed;
      --ok:#22c55e;
      --danger:#ef4444;
      --shadow: 0 16px 50px rgba(0,0,0,.45);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      background:linear-gradient(180deg,#070812 0%,var(--bg) 70%);
      color:var(--text);
    }
    a{color:#c4b5fd;text-decoration:none}
    a:hover{text-decoration:underline}

    header{
      position:sticky; top:0; z-index:20;
      background:rgba(11,12,16,.86);
      backdrop-filter: blur(12px);
      border-bottom:1px solid var(--line);
    }
    .wrap{max-width:1200px;margin:0 auto;padding:12px 14px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between}
    h1{margin:0;font-size:18px;letter-spacing:.2px}
    .hint{font-size:12px;color:var(--muted)}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace}

    .btn{
      border:1px solid var(--line);
      background:var(--panel2);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:850;
      box-shadow:0 0 0 rgba(0,0,0,0);
      user-select:none;
    }
    .btn:hover{border-color:rgba(255,255,255,.22)}
    .btn.primary{background:var(--accent);border-color:rgba(124,58,237,.55)}
    .btn.ok{background:rgba(34,197,94,.12);border-color:rgba(34,197,94,.35);color:#bbf7d0}
    .btn.danger{background:rgba(239,68,68,.12);border-color:rgba(239,68,68,.35);color:#fecaca}
    .btn.ghost{background:transparent}
    .btn.small{padding:8px 10px;border-radius:10px;font-size:12px}

    .btnSm{
  padding:6px 10px;
  border-radius:10px;
  font-size:12px;
  font-weight:850;
  line-height:1;
}

.ingHdTop{
  display:flex;
  gap:10px;
  align-items:center;
  flex-wrap:wrap;
}

.toggleAllWrap{
  display:inline-flex;
  align-items:center;
  gap:8px;
  padding:6px 10px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.12);
  background:rgba(255,255,255,.04);
  cursor:pointer;
  user-select:none;
}
.toggleAllWrap input{
  width:16px;
  height:16px;
  cursor:pointer;
}
.toggleAllText{
  font-size:12px;
  font-weight:850;
  line-height:1;
  opacity:.9;
}

.scaleTools{
  display:flex;
  flex-direction:column;
  align-items:flex-end;
  gap:6px;
}

.scaleBtns{
  display:flex;
  gap:8px;
  align-items:center;
  flex-wrap:wrap;
  justify-content:flex-end;
}

.scaleServings{
  display:flex;
  gap:8px;
  align-items:center;
  flex-wrap:wrap;
  justify-content:flex-end;
}

.scaleInput{
  width:84px;
  padding:6px 8px;
  border-radius:10px;
  border:1px solid var(--line);
  background:var(--panel2);
  color:var(--text);
}

.mono{ font-family: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace; }


    input,select,textarea{
      width:100%;
      border:1px solid var(--line);
      background:var(--panel);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      outline:none;
    }
    textarea{min-height:120px;resize:vertical}

    /* Page layout */
    .main{max-width:1200px;margin:0 auto;padding:14px}
    .filters{
      display:grid;
      grid-template-columns: 1.5fr 1fr 1fr;
      gap:10px;
      align-items:end;
    }
    /* Advanced filters dropdown */
.adv{
  grid-column: 1 / -1;
  border:1px solid var(--line);
  background:rgba(18,20,27,.55);
  border-radius:16px;
  padding:10px 12px;
}
.adv > summary{
  cursor:pointer;
  font-weight:900;
  list-style:none;
  user-select:none;
}
.adv > summary::-webkit-details-marker{ display:none; }
.advGrid{
  margin-top:10px;
  display:grid;
  grid-template-columns: repeat(5, minmax(0,1fr));
  gap:10px;
  align-items:end;
}
@media(max-width:980px){
  .advGrid{ grid-template-columns: 1fr 1fr; }
}
@media(max-width:520px){
  .advGrid{ grid-template-columns: 1fr; }
}

    @media(max-width:980px){
      .filters{grid-template-columns:1fr 1fr; }
    }
    @media(max-width:520px){
      .filters{grid-template-columns:1fr; }
    }
    .k{font-size:12px;color:var(--muted);margin-bottom:6px}

    /* Gallery grid */
    .galleryTop{
      display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;
      margin-top:12px;
    }
    .seg{
      display:flex;gap:8px;align-items:center;flex-wrap:wrap;
    }
    .seg .btn{padding:8px 10px;font-size:12px}
    .seg input[type="range"]{width:170px}
    .count{color:var(--muted);font-size:12px}

    .grid{
      display:grid;
      gap:12px;
      margin-top:12px;
      grid-template-columns: repeat(4, minmax(0,1fr));
    }
    @media(max-width:1100px){.grid{grid-template-columns: repeat(3, minmax(0,1fr));}}
    @media(max-width:800px){.grid{grid-template-columns: repeat(2, minmax(0,1fr));}}
    @media(max-width:520px){.grid{grid-template-columns: repeat(2, minmax(0,1fr));}}
    @media(max-width:520px){.tileBody{padding:12px 12px 14px}}
    @media(max-width:520px){.tileTitle{font-size:16px}}

    .tile{
      border:1px solid var(--line);
      background:rgba(18,20,27,.65);
      border-radius:18px;
      overflow:hidden;
      cursor:pointer;
      box-shadow:0 8px 24px rgba(0,0,0,.18);
      transition: transform .10s ease, border-color .10s ease;
    }
    .tile:hover{border-color:rgba(255,255,255,.22); transform: translateY(-1px);}
    .imgBox{position:relative; aspect-ratio: 4 / 3; background:rgba(255,255,255,.03)}
    .imgBox img{
      position:absolute; inset:0;
      width:100%; height:100%;
      object-fit:cover;
      display:block;
    }
    .imgFallback{
      position:absolute; inset:0;
      display:flex;align-items:center;justify-content:center;
      color:rgba(238,242,255,.45);
      font-size:12px;
    }
    .tileBody{padding:10px 10px 12px}
    .tileTitle{font-weight:950;line-height:1.2; letter-spacing:.2px}
    .tileMeta{
      margin-top:8px;
      display:flex;gap:8px;flex-wrap:wrap;
      color:rgba(238,242,255,.72);
      font-size:12px;
    }
    .pill{
      font-size:12px;padding:3px 8px;border-radius:999px;
      border:1px solid var(--line);
      background:rgba(255,255,255,.04);
    }

    /* Edit suggestions (clickable chips) */
    .suggestRow{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin-top:8px;
    }
    .chipBtn{
      border:1px solid var(--line);
      background:rgba(255,255,255,.04);
      color:var(--text);
      padding:6px 10px;
      border-radius:999px;
      cursor:pointer;
      font-weight:800;
      font-size:12px;
    }
    .chipBtn:hover{ border-color:rgba(255,255,255,.22); }


    .badge{
      display:inline-flex;align-items:center;gap:6px;
    }
    .dot{width:8px;height:8px;border-radius:999px;background:rgba(34,197,94,.9);display:inline-block}

    /* Tiny sync badge */
.syncPill{
  display:inline-flex;
  align-items:center;
  gap:6px;
  padding:2px 8px;
  border-radius:999px;
  border:1px solid var(--line);
  background:rgba(255,255,255,.04);
  font-size:12px;
  font-weight:850;
  line-height:1.4;
}
.syncDot{
  width:8px;height:8px;border-radius:999px;
  background:rgba(148,163,184,.95); /* default: gray */
  display:inline-block;
}
.syncPill.ok .syncDot{ background:rgba(34,197,94,.95); }
.syncPill.warn .syncDot{ background:rgba(245,158,11,.95); }
.syncPill.bad  .syncDot{ background:rgba(239,68,68,.95); }


    /* Viewer modal (full screen on mobile) */
    .overlay{
      position:fixed; inset:0;
      background:rgba(0,0,0,.65);
      display:none;
      z-index:50;
    }
    .overlay.show{display:block}
    .viewer{
      position:fixed; inset:0;
      display:none;
      z-index:60;
      background:linear-gradient(180deg, rgba(7,8,18,.98) 0%, rgba(11,12,16,.98) 60%);
      overflow:auto;
      -webkit-overflow-scrolling:touch;
    }
    .viewer.show{display:block}
    .viewerInner{max-width:900px;margin:0 auto;padding:14px}
    .viewerTop{
      position:sticky; top:0; z-index:80;
      background:rgba(11,12,16,.86);
      backdrop-filter: blur(12px);
      border-bottom:1px solid var(--line);
    }
    .viewerTop .wrap{max-width:900px}
    .viewerHeader{
      display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;
    }
    .viewerTitle{font-size:18px;font-weight:950;letter-spacing:.2px;margin:0}
    .viewerSub{font-size:12px;color:var(--muted);margin-top:4px}
    .viewerHero{
      margin-top:14px;
      border:1px solid var(--line);
      border-radius:18px;
      overflow:hidden;
      box-shadow: var(--shadow);
      background:rgba(255,255,255,.03);
    }
    .viewerHero img{width:100%;height:auto;display:block;max-height:420px;object-fit:cover}
    .section{
      margin-top:14px;
      border:1px solid var(--line);
      border-radius:16px;
      background:rgba(18,20,27,.65);
      overflow:hidden;
    }
    .sectionHd{
      padding:12px;
      border-bottom:1px solid var(--line);
      background:rgba(23,26,35,.55);
      display:flex;justify-content:space-between;gap:10px;align-items:center;
      flex-wrap:wrap;
    }
    .sectionBd{padding:12px}
    .h2{margin:0;font-size:14px;font-weight:950;letter-spacing:.2px}

    .pre{
      white-space:pre-wrap;
      line-height:1.55;
      font-size:14px;
      color:rgba(238,242,255,.92);
    }
    .kv{display:flex;gap:10px;flex-wrap:wrap;color:rgba(238,242,255,.78);font-size:12px}
    .kv .pill{background:rgba(255,255,255,.03)}
    .viewerFooterSpace{height:18px}

    /* Ingredients bullets + checkboxes */
    .ingList{
      list-style: none;
      padding:0;
      margin:0;
      display:grid;
      gap:10px;
    }
    .ingItem{
      display:flex;
      gap:10px;
      align-items:flex-start;
      padding:10px 10px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.03);
      border-radius:14px;
    }
    .ingItem input{
      width:auto;
      margin-top:2px;
      transform: scale(1.15);
      accent-color: var(--accent);
    }
    .ingText{
      line-height:1.5;
      font-size:14px;
      color:rgba(238,242,255,.92);
      flex:1;
    }
    .ingText.checked{
      opacity:.60;
      text-decoration: line-through;
    }
    .ingHeader{
      font-weight:950;
      letter-spacing:.2px;
      padding:10px 10px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(124,58,237,.14);
      border-radius:14px;
    }

    /* Edit modal inside viewer */
    .editPanel{
      border:1px solid var(--line);
      border-radius:16px;
      background:rgba(18,20,27,.80);
      overflow:hidden;
      margin-top:14px;
      display:none;
    }
    .editPanel.show{display:block}

    .two{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    @media(max-width:650px){.two{grid-template-columns:1fr}}

    /* Snackbar */
    .snack{
      position:fixed;
      left:50%;
      bottom:14px;
      transform:translateX(-50%);
      display:none;
      gap:10px;
      align-items:center;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid var(--line);
      background:rgba(18,20,27,.92);
      box-shadow: var(--shadow);
      z-index:999;
      max-width:min(900px, calc(100vw - 28px));
    }
    .snack.show{display:flex}
    .snackMsg{color:rgba(238,242,255,.92); font-size:13px}

        /* Cook Mode (bigger, easier to read on phone) */
    body.cookMode .viewerInner{ font-size: 18px; }
    body.cookMode .pre{ font-size: 18px; line-height: 1.65; }
    body.cookMode .ingText{ font-size: 18px; line-height: 1.65; }
    body.cookMode .viewerTitle{ font-size: 22px; }
    body.cookMode .sectionBd{ padding: 14px; }
    body.cookMode .ingItem{ padding: 12px 12px; }
    body.cookMode .ingItem input{ transform: scale(1.35); }



    body.gated main,
body.gated #viewer,
body.gated #overlay { display:none !important; }

body.gated #headerControls { display:none !important; }
body.gated #loginGate { display:flex !important; }

/* Header Advanced menu dropdown (separate from Advanced filters panel) */
.advMenu{
  position: relative;
  border: none;
  background: transparent;
  padding: 0;
  margin: 0;
  display: inline-block;
}

.advMenu > summary{
  list-style: none;
  cursor: pointer;
}
.advMenu > summary::-webkit-details-marker{ display:none; }

/* Dropdown panel */
.advMenu .advPanel{
  position: absolute;
  top: calc(100% + 8px);
  left: 0;
  background: var(--panel, #111);
  border: 1px solid rgba(255,255,255,.12);
  border-radius: 12px;
  padding: 10px;
  display: flex;
  flex-direction: column;
  gap: 8px;
  z-index: 9999;
  min-width: 180px;
}

/* Paste recipe modal */
.pasteModal{
  position:fixed; inset:0;
  background:rgba(0,0,0,.65);
  display:none;
  z-index:140;
  padding:16px;
  align-items:center;
  justify-content:center;
}
.pasteModal.show{ display:flex; }
.pasteCard{
  width:min(900px, 100%);
  background:rgba(18,20,27,.96);
  border:1px solid var(--line);
  border-radius:16px;
  box-shadow: var(--shadow);
  overflow:hidden;
}
.pasteCardHd{
  padding:12px;
  border-bottom:1px solid var(--line);
  background:rgba(23,26,35,.55);
  display:flex;
  gap:10px;
  align-items:center;
  justify-content:space-between;
  flex-wrap:wrap;
}
.pasteCardBd{ padding:12px; }
#pasteRecipeText{ min-height:260px; max-height:60vh; }


  </style>
</head>

<body>
<header>
  <div class="wrap">
    <div class="row">
      <div>
        <h1>Jake's Recipe Book</h1>
        <div class="hint">
          Big-photo gallery • Tap a recipe to open a clean cooking view • <span id="cloud"></span> • <span id="syncBadge" class="syncPill">Signed out</span> <span id="status"></span>
        </div>
      </div>
      <div id="headerControls" style="display:flex;gap:10px;flex-wrap:wrap;align-items:center">
        <details id="advancedMenu" class="advMenu">
          <summary class="btn">Advanced</summary>
          <div class="advPanel">
            <button class="btn" id="backupBtn">Backup</button>
            <button class="btn" id="restoreBtn">Restore</button>
          
            <button class="btn ok" id="pushCloudBtn"
              title="Use ONLY if you intentionally want this device to overwrite the cloud copy (e.g., recovery).">
              Push to cloud
            </button>
          
            <button class="btn danger" id="signOutBtn">Sign out</button>
          </div>
          
        </details>
        
        <details id="importMenu" class="advMenu">
          <summary class="btn">Import</summary>
          <div class="advPanel">
            <button class="btn" id="pasteRecipeActionBtn" type="button">Paste recipe</button>
            <button class="btn" id="importHtmlActionBtn" type="button">Import HTML</button>
          </div>
        </details>

        <button class="btn primary" id="newBtn">+ New</button>

        
        <input id="importFile" type="file" accept="application/json" style="display:none" />
        <input id="importHtmlFile" type="file" accept=".html,text/html" style="display:none" />
        
        
      </div>
      
    </div>
  </div>
</header>

<div id="loginGate" style="display:none;min-height:calc(100vh - 60px);align-items:center;justify-content:center;text-align:center;padding:28px">
  <div style="max-width:520px">
    <h2 style="margin:0 0 8px;font-size:24px;letter-spacing:.2px">Jake's Recipe Book</h2>
    <div class="hint" style="margin:0 0 10px">Sign in to view and edit recipes.</div>
<div class="hint" style="margin:0 0 14px">First sign-in on a new device requires internet. After that, this device can work offline.</div>

    <div id="loginGateBtnHost" style="display:flex;justify-content:center"></div>
  </div>
</div>


<main class="main">
<div class="filters">
  <div>
    <div class="k">Search</div>
    <input id="q" placeholder="Search title, ingredients, directions, tags…" />
  </div>

  <div>
    <div class="k">Main ingredient</div>
    <select id="ingredientF"><option value="">Any</option></select>
  </div>

  <div>
    <div class="k">Max time (min)</div>
    <input id="maxTime" type="number" min="0" step="5" placeholder="e.g. 30" />
  </div>

  <details class="adv" id="advFilters">
    <summary>Advanced filters</summary>
    <div class="advGrid">
      <div>
        <div class="k">Cuisine</div>
        <select id="cuisineF"><option value="">Any</option></select>
      </div>

      <div>
        <div class="k">Equipment</div>
        <select id="equipmentF"><option value="">Any</option></select>
      </div>

      <div>
        <div class="k">Dish Type</div>
        <select id="dishTypeF"><option value="">Any</option></select>
      </div>


      <div>
        <div class="k">Base</div>
        <select id="baseF"><option value="">Any</option></select>
      </div>

      <div>
        <div class="k">Tag</div>
        <select id="tagF"><option value="">Any</option></select>
      </div>
    </div>
  </details>
</div>



  <div class="galleryTop">
    <div class="seg">
      <div class="k" style="margin:0;">Card size (← smaller • larger →)</div>
      <input id="size" type="range" min="2" max="6" value="4" />
      <select id="sort" style="max-width:240px">
        <option value="updated">Sort: Recently updated</option>
        <option value="title">Sort: Title A→Z</option>
        <option value="cooked">Sort: Most cooked</option>
        <option value="time">Sort: Shortest time</option>
      </select>
      <button class="btn" id="clearFiltersBtn" title="Clear search + all filters">Clear filters</button>

    </div>
    <div class="count"><span id="count">0</span> recipes</div>
  </div>

  <div class="grid" id="grid"></div>
</main>

<!-- Overlay + viewer -->
<div class="overlay" id="overlay"></div>

<div class="viewer" id="viewer" aria-hidden="true">
  <div class="viewerTop">
    <div class="wrap">
      <div class="viewerHeader">
        <button class="btn ghost" id="backBtn">← Back</button>
        <div style="display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end">
  <button class="btn small ok" id="markCookedBtn" title="Prevents double-taps; offers Undo">Cooked +1</button>
  <button class="btn small" id="copyGroceriesBtn" title="Copy ingredients to paste into Apple Reminders">Copy groceries</button>
  <button class="btn small" id="downloadGroceriesBtn" title="Download ingredients as a .txt file">Groceries .txt</button>
  <button class="btn small" id="downloadOneBtn" title="Downloads a clean 1-page recipe card (uses your current scaling)">Download recipe</button>
  <button class="btn" id="printBtn">Print Card</button>
  <button class="btn small" id="cookModeBtn" title="Bigger text + tries to keep screen awake">Cook Mode</button>
  <button class="btn small primary" id="editToggleBtn">Edit</button>
  <button class="btn small danger" id="deleteBtn">Delete</button>
</div>

      </div>
    </div>
  </div>

  <div class="viewerInner">
    <h2 class="viewerTitle" id="vTitle"></h2>
    <div class="viewerSub" id="vSub"></div>
<div class="viewerSub" id="wakeHint" style="display:none;"></div>


    <div class="viewerHero" id="vHero" style="display:none;">
      <img id="vImg" alt="" />
    </div>

    <div class="section">
      <div class="sectionHd">
        <div class="h2">Quick info</div>
        <div class="kv" id="vInfo"></div>
      </div>
      <div class="sectionBd">
        <div class="hint" id="vSource"></div>
      </div>
    </div>

    <div class="section">
      <div class="sectionHd">
        <div>
          <div class="ingHdTop">
            <div class="h2">Ingredients</div>
            <label class="toggleAllWrap" title="Check/clear all ingredients">
              <input type="checkbox" id="toggleAllIngCb" />
              <span class="toggleAllText">Check all</span>
            </label>
            
          </div>
          <div class="hint">Tap checkboxes as you cook (saved on this device)</div>
        </div>
    
        <div class="scaleTools" aria-label="Scale recipe">
          <div class="scaleBtns">
            <span class="pill">Scale</span>
            <button class="btn btnSm" id="scaleDown" type="button" title="Decrease">−</button>
            <button class="btn btnSm" id="scaleReset" type="button" title="Reset to 1×">1×</button>
            <button class="btn btnSm" id="scaleUp" type="button" title="Increase">+</button>
          </div>
    
          <div class="scaleServings" id="scaleServingsRow" style="display:none;">
            <span class="muted">Servings</span>
            <span id="scaleServingsBase" class="mono"></span>
            <span class="muted">→</span>
            <input id="scaleServingsTarget" class="scaleInput" type="number" min="0.5" step="0.5" inputmode="decimal" />
          </div>
    
          <div class="hint" id="scaleMeta"></div>
        </div>
      </div>
    

  <div class="sectionBd">
    <div id="vIngredients"></div>
  </div>
</div>


    <div class="section">
      <div class="sectionHd"><div class="h2">Directions</div></div>
      <div class="sectionBd"><div class="pre" id="vDirections"></div></div>
    </div>

    <div class="section" id="vNotesWrap" style="display:none;">
      <div class="sectionHd"><div class="h2">Notes</div></div>
      <div class="sectionBd"><div class="pre" id="vNotes"></div></div>
    </div>

    <!-- Edit panel (only shows if you click Edit) -->
    <div class="editPanel" id="editPanel">
      <div class="sectionHd">
        <div class="h2">Edit recipe</div>
        <div style="display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end">
          <button class="btn small" id="cancelEditBtn">Cancel</button>
          <button class="btn small primary" id="saveEditBtn">Save</button>
        </div>
      </div>
      <div class="sectionBd">
        <div class="two">
          <div>
            <div class="k">Title</div>
            <input id="eTitle"/>
          </div>
          <div>
          <div class="k">Cuisine</div>
          <input id="eCuisine" placeholder="Mexican (optional)" autocomplete="off"/>
          <div class="suggestRow" id="cuisineSuggestions"></div>

          </div>
        </div>

        <div class="two" style="margin-top:10px;">
          <div>
            <div class="k">Dish Type</div>
            <input id="eDishType" placeholder="Breakfast, dinner, snack, beverage, dip/spread, sauce/dressing…" autocomplete="off"/>
            <div class="suggestRow" id="dishTypeSuggestions"></div>
          </div>
          <div>
            <div class="k">Base</div>
            <input id="eBase" placeholder="Soup, sandwich, rice, pasta…" autocomplete="off"/>
            <div class="suggestRow" id="baseSuggestions"></div>
          </div>
        </div>
        

<div class="two" style="margin-top:10px;">
  <div>
    <div class="k">Main ingredient / protein</div>
    <input id="eIngredient" placeholder="chicken, tofu, beans…" autocomplete="off"/>
    <div class="suggestRow" id="ingredientSuggestions"></div>
  </div>
  <div>
    <div class="k">Time (minutes)</div>
    <input id="eTime" type="number" min="0" step="5" placeholder="30"/>
  </div>
</div>

<div class="two" style="margin-top:10px;">
  <div>
    <div class="k">Equipment</div>
    <input id="eEquipment" placeholder="Instant Pot, oven, air fryer…" autocomplete="off"/>
    <div class="suggestRow" id="equipmentSuggestions"></div>
  </div>
  <div>
    <div class="k">Tags</div>
    <input id="eTags" placeholder="weeknight, spicy, meal prep" autocomplete="off"/>
    <div class="suggestRow" id="tagSuggestions"></div>
  </div>
</div>


<div class="two" style="margin-top:10px;">
  <div>
    <div class="k">Dishes created</div>
    <input id="eDishes" type="number" min="0" step="1" placeholder="2"/>
  </div>
  <div>
    <div class="k">Cooked count (editable)</div>
    <input id="eCookedCount" type="number" min="0" step="1" placeholder="0"/>
  </div>
</div>

<div class="two" style="margin-top:10px;">
  <div>
    <div class="k">Servings</div>
    <input id="eServings" placeholder="yields 4"/>
  </div>
  <div></div>
</div>


<div style="margin-top:10px;">
  <div class="k">Recipe image</div>

  <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center">
    <button class="btn small" id="addImageBtn" type="button">Add / Change image</button>
    <button class="btn small danger" id="removeImageBtn" type="button" style="display:none;">Remove image</button>

    <!-- iOS: this opens Photos and also offers Camera (capture is a hint) -->
    <input id="imageFileInput" type="file" accept="image/*" style="display:none;" />

  </div>

  <img id="eImagePreview" alt="" style="display:none;max-width:100%;height:auto;margin-top:10px;border-radius:14px;border:1px solid var(--line);" />

  <!-- keep these for saving -->
  <input id="eImageUrl" style="display:none;" />
  <input id="eImagePath" style="display:none;" />

  <div class="hint" style="margin-top:6px;">On iPhone: choose from Photos or take a new picture.</div>
</div>


        <div style="margin-top:10px;">
          <div class="k">Source URL</div>
          <input id="eSourceUrl" placeholder="https://…"/>
        </div>

        <div style="margin-top:10px;">
          <div class="k">Ingredients</div>
          <textarea id="eIngredients"></textarea>
        </div>
        <div style="margin-top:10px;">
          <div class="k">Directions</div>
          <textarea id="eDirections"></textarea>
        </div>
        <div style="margin-top:10px;">
          <div class="k">Notes</div>
          <textarea id="eNotes"></textarea>
        </div>

        <div class="hint" style="margin-top:10px;" id="editStats"></div>
      </div>
    </div>

    <div class="viewerFooterSpace"></div>
  </div>
</div>

<!-- Paste Recipe modal -->
<div id="pasteModal" class="pasteModal" aria-hidden="true">
  <div class="pasteCard" role="dialog" aria-modal="true" aria-label="Paste recipe">
    <div class="pasteCardHd">
      <div>
        <div class="h2">Paste recipe</div>
        <div class="hint">Paste from ChatGPT or anywhere. Headings like “Ingredients:” and “Directions:” help.</div>
      </div>
      <div style="display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end">
        <button class="btn small" id="pasteCancelBtn" type="button">Cancel</button>
        <button class="btn small primary" id="pasteImportBtn" type="button">Import</button>
      </div>
    </div>
    <div class="pasteCardBd">
      <div class="k">Recipe text</div>
      <textarea id="pasteRecipeText" placeholder="Paste the whole recipe here…"></textarea>
      <div class="hint" style="margin-top:8px;">
        Examples it understands: “Ingredients:”, “Directions: / Instructions: / Method:”, “Notes:”
      </div>
    </div>
  </div>
</div>


<!-- Snackbar -->
<div id="snack" class="snack" aria-live="polite">
  <span id="snackMsg" class="snackMsg"></span>
  <button id="snackUndo" class="btn small">Undo</button>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-app.js";
  import {
    getFirestore,
    collection,
    getDocs,
    writeBatch,
    doc,
    onSnapshot,
    query
  } from "https://www.gstatic.com/firebasejs/12.7.0/firebase-firestore.js";

  import {
  getAuth,
  setPersistence,
  browserLocalPersistence,
  GoogleAuthProvider,
  signInWithPopup,
  onAuthStateChanged,
  signOut
} from "https://www.gstatic.com/firebasejs/12.7.0/firebase-auth.js";

import {
  getStorage,
  ref as sRef,
  uploadBytes,
  getDownloadURL,
  deleteObject
} from "https://www.gstatic.com/firebasejs/12.7.0/firebase-storage.js";


  const firebaseConfig = {
    apiKey: "AIzaSyAFgODyKQFacEO3xfslhTeeU4n2hKcAy2s",
    authDomain: "jake-recipes.firebaseapp.com",
    projectId: "jake-recipes",
    storageBucket: "jake-recipes.firebasestorage.app",
    messagingSenderId: "337488882837",
    appId: "1:337488882837:web:78b7ad6a163eaac4b3bf9c",
    measurementId: "G-1PQX8MWL3J"
  };

  const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
const storage = getStorage(app);


  // --- Auth (Google Sign-In) ---
const auth = getAuth(app);
setPersistence(auth, browserLocalPersistence).catch(console.warn);

const provider = new GoogleAuthProvider();
// optional: always show account picker
provider.setCustomParameters({ prompt: "select_account" });

let _currentUser = null;
let _authInitDone = false;
let _authInitResolve;
const _authInit = new Promise((res)=>{ _authInitResolve = res; });

function ensureAuthButton(){
  let btn = document.getElementById("authBtn");
  if(btn) return btn;

  btn = document.createElement("button");
  btn.id = "authBtn";

  const newBtn = document.getElementById("newBtn"); // your "+ New" button
  btn.className = newBtn ? newBtn.className : "btn";

  if(newBtn && newBtn.parentElement){
    newBtn.insertAdjacentElement("afterend", btn);
  } else {
    // fallback
    btn.style.position = "fixed";
    btn.style.top = "12px";
    btn.style.right = "12px";
    btn.style.zIndex = 9999;
    document.body.appendChild(btn);
  }

  return btn;
}


function renderAuthButton(){
  const btn = ensureAuthButton();
  const host = document.getElementById("loginGateBtnHost");

  if(_currentUser){
    btn.style.display = "none";
    return;
  }

  btn.textContent = "Sign in with Google";
  btn.style.display = "";

  // Move button into the centered gate UI when signed out
  if(host) host.appendChild(btn);

  btn.onclick = async ()=>{
  // First-time sign-in requires internet
  if(!navigator.onLine){
    alert("You're offline. Connect to the internet once to sign in on this device.");
    return;
  }

  try{
    await signInWithPopup(auth, provider);
    // No refresh needed; onAuthStateChanged will fire and the app will swap in
  }catch(e){
    console.error("Google sign-in failed:", e);
    alert("Sign-in failed. If this keeps happening, allow popups for this site and check Firebase Authorized Domains.");
  }
};
}


onAuthStateChanged(auth, (user)=>{
  _currentUser = user || null;
  renderAuthButton();
  if(!_authInitDone){
    _authInitDone = true;
    _authInitResolve(_currentUser);
  }

  if (window.__onAuthChange) window.__onAuthChange(_currentUser);

});

// Expose auth state to the non-module script
window._authInit = _authInit;
window._getCurrentUser = () => _currentUser;

window.AUTH = {
  signOut: () => signOut(auth)
};




  // Minimal helpers exposed to your existing (non-module) script
  window.FB = {
    enabled: true,

    async loadAll(){
      const snap = await getDocs(collection(db, "recipes"));
      return snap.docs.map(d => ({ id: d.id, ...d.data() }));
    },

    // Make cloud exactly match local (writes all + deletes removed docs)
    async syncAll(recipes){
      const col = collection(db, "recipes");
      const snap = await getDocs(col);

      const existingIds = new Set(snap.docs.map(d => d.id));
      const desiredIds = new Set((recipes || []).map(r => r?.id).filter(Boolean));

      const batch = writeBatch(db);

      // Delete docs that no longer exist locally
      for(const id of existingIds){
        if(!desiredIds.has(id)){
          batch.delete(doc(col, id));
        }
      }

      // Upsert all local recipes
      for(const r of (recipes || [])){
        if(!r || !r.id) continue;
        batch.set(doc(col, r.id), r);
      }

      await batch.commit();
    },

    // Live updates from cloud
    subscribe(onData){
      const col = collection(db, "recipes");
      return onSnapshot(query(col), (snap)=>{
        const list = snap.docs.map(d => ({ id: d.id, ...d.data() }));
        onData(list);
      });
    }
  };

  // --- Storage helpers (upload/delete recipe images) ---
  window.FB.uploadRecipeImage = async ({ recipeId, file, filenameHint } = {}) => {

    if(!_currentUser) throw new Error("Not signed in");
    if(!recipeId) throw new Error("Missing recipeId");
    if(!file) throw new Error("Missing file");

    // Keep names safe-ish
    const safeName = String(filenameHint || file.name || "image").replace(/[^\w.\-]+/g, "_");

    const path = `recipeImages/${_currentUser.uid}/${recipeId}/${Date.now()}_${safeName}`;

    const fileRef = sRef(storage, path);
    await uploadBytes(fileRef, file, { contentType: file.type || "image/jpeg" });
    const url = await getDownloadURL(fileRef);

    return { url, path };
  };

  window.FB.deleteRecipeImage = async (path) => {
    if(!_currentUser) throw new Error("Not signed in");
    if(!path) return;
    const fileRef = sRef(storage, path);
    await deleteObject(fileRef);
  };


</script>

<script>

  const LS_KEY = "recipe_book_data_v3_gallery";
  const CHECKS_PREFIX = "rb_ing_checks_v1:"; // per-recipe checkbox state

  // Per-recipe last-used scaling (saved on this device)
  const SCALE_STORE_KEY = "rb.scaleById.v1";
  
  const $ = (id)=>document.getElementById(id);

  function setGate(on){
  document.body.classList.toggle("gated", !!on);
}

window._doSignOut = async ()=> {
  await (window.AUTH?.signOut?.());
};



  function waitForFB(timeoutMs = 4000){
  if(window.FB && window.FB.enabled) return Promise.resolve(true);
  return new Promise((resolve)=>{
    const start = Date.now();
    const t = setInterval(()=>{
      if(window.FB && window.FB.enabled){
        clearInterval(t);
        resolve(true);
      }else if(Date.now() - start > timeoutMs){
        clearInterval(t);
        resolve(false);
      }
    }, 50);
  });
}

  const state = {
  recipes: [],
  selectedId: null,
  editOpen: false,
  scaleFactor: 1,
  baseServings: null
};


// Comma-split helper (keeps original casing)
const normalizeList = (s)=> (s||"").split(",").map(x=>x.trim()).filter(Boolean);

function canonicalTag(s){
  s = String(s || "").trim().replace(/\s+/g, " ");
  if(!s) return "";

  // Lowercase then Title Case each word/segment
  const lower = s.toLowerCase();

  // Keep a few common acronyms uppercase (optional)
  const ACRONYMS = new Set(["bbq","usa","uk","ai","ip"]); // add/remove as you want

  const cap = (seg)=>{
    if(!seg) return seg;
    if(ACRONYMS.has(seg)) return seg.toUpperCase();
    return seg.charAt(0).toUpperCase() + seg.slice(1);
  };

  return lower.split(" ").map(word=>{
    // Title-case hyphenated parts too: italian-american -> Italian-American
    if(word.includes("-")){
      return word.split("-").map(cap).join("-");
    }
    return cap(word);
  }).join(" ");
}


// Accept string OR array, return array of strings
function toArray(v){
  if(Array.isArray(v)) return v.map(x=>String(x||"").trim()).filter(Boolean);
  if(typeof v === "string") return normalizeList(v);
  if(v == null) return [];
  return [String(v).trim()].filter(Boolean);
}

// Canonicalize + de-dupe list values (case-insensitive)
function canonicalList(v){
  const arr = toArray(v).map(canonicalTag).filter(Boolean);
  const seen = new Set();
  const out = [];
  for(const x of arr){
    const k = x.toLowerCase();
    if(seen.has(k)) continue;
    seen.add(k);
    out.push(x);
  }
  return out;
}

// Canonicalize single-value fields like cuisine/course
function canonicalOne(v){
  return canonicalTag(String(v||""));
}

// Optional: run once after loading data to clean it up
function normalizeAllRecipesInPlace(){
  state.recipes = (state.recipes || []).map(r=>{
    return {
      ...r,
      cuisine: canonicalList(r.cuisine),
      dishType: canonicalList(r.dishType ?? r.course),     // ← course -> dishType
      base: canonicalList(r.base),

      mainIngredient: canonicalList(r.mainIngredient),
      equipment: canonicalList(r.equipment ?? r.appliances), // ← appliances -> equipment
      tags: canonicalList(r.tags)

    };
  });
}


// Accept either: "chicken" OR "chicken, sausage" OR ["chicken","sausage"]
function toList(v){
  if(Array.isArray(v)) return v.map(x=>String(x||"").trim()).filter(Boolean);
  if(typeof v === "string") return normalizeList(v);
  return [];
}
function toListLower(v){
  if(Array.isArray(v)) return v.map(x=>String(x||"").trim().toLowerCase()).filter(Boolean);
  if(typeof v === "string") return normalizeList(String(v).toLowerCase());
  return [];
}
function listToDisplay(v){
  return toList(v).join(", ");
}

  const uid = ()=> Math.random().toString(36).slice(2,10) + "-" + Date.now().toString(36);

// ---- Edit suggestions (reuse + filter saved values) ----
let ALL_CUISINES = [];
let ALL_DISH_TYPES = [];
let ALL_BASES = [];
let ALL_INGREDIENTS = [];
let ALL_EQUIPMENT = [];
let ALL_TAGS = [];

function rebuildTagCaches(){
  const cuisineSet = new Set();
  const dishTypeSet = new Set();
  const baseSet = new Set();
  const ingredientSet = new Set();
  const equipmentSet = new Set();
  const tagSet = new Set();


  for(const r of state.recipes || []){
    for(const c of toList(r.cuisine)){
      const cc = String(c||"").trim();
      if(cc) cuisineSet.add(cc);
    }

    for(const dt of toList(r.dishType)){
      const dtt = String(dt||"").trim();
      if(dtt) dishTypeSet.add(dtt);
    }


  for(const b of toList(r.base)){
    const bb = String(b||"").trim();
    if(bb) baseSet.add(bb);
  }

  for(const ing of toList(r.mainIngredient)){
    const ii = String(ing||"").trim();
    if(ii) ingredientSet.add(ii);
  }


  for(const eq of toList(r.equipment)){
      const eqq = String(eq || "").trim();
      if(eqq) equipmentSet.add(eqq);
    }

    for(const t of (r.tags || [])){
      const tag = String(t || "").trim();
      if(tag) tagSet.add(tag);
    }
  }

  const sortAlpha = (a,b)=>a.localeCompare(b);

  ALL_CUISINES = Array.from(cuisineSet).sort(sortAlpha);
  ALL_DISH_TYPES = Array.from(dishTypeSet).sort(sortAlpha);
  ALL_BASES = Array.from(baseSet).sort(sortAlpha);
  ALL_INGREDIENTS = Array.from(ingredientSet).sort(sortAlpha);
  ALL_EQUIPMENT = Array.from(equipmentSet).sort(sortAlpha);
  ALL_TAGS = Array.from(tagSet).sort(sortAlpha);
}

function lastCommaToken(inputValue){
  const parts = String(inputValue || "").split(",");
  return (parts[parts.length - 1] || "").trim().toLowerCase();
}

function filterList(values, q){
  const qq = (q || "").trim().toLowerCase();
  if(!qq) return values;
  return values.filter(v => String(v).toLowerCase().includes(qq));
}

function renderSuggestChips(hostId, values, q, onPick){
  const host = $(hostId);
  if(!host) return;
  host.innerHTML = "";

  const qq = (q || "").trim();
  const filtered = filterList(values, qq).slice(0, 30);
  const shownSet = new Set(filtered.map(v => String(v).toLowerCase()));

  // Offer "Add" if typed value isn't already in the list
  if(qq && !shownSet.has(qq.toLowerCase())){
    const addBtn = document.createElement("button");
    addBtn.type = "button";
    addBtn.className = "chipBtn";
    addBtn.textContent = `+ Add "${qq}"`;
    addBtn.addEventListener("click", (e)=>{
      e.preventDefault();
      onPick(qq);
      rebuildTagCaches();
      refreshEditSuggestions();
    });
    host.appendChild(addBtn);
  }

  filtered.forEach(v=>{
    const b = document.createElement("button");
    b.type = "button";
    b.className = "chipBtn";
    b.textContent = v;
    b.addEventListener("click", (e)=>{
      e.preventDefault();
      onPick(v);
      refreshEditSuggestions();
    });
    host.appendChild(b);
  });
}

// Replace the LAST comma token with the selected value (for comma-fields)
function replaceLastCommaTokenWith(inputId, value, opts={}){
  const input = $(inputId);
  if(!input) return;

  const trailingComma = opts.trailingComma ?? true;

  let wanted = String(value || "").trim();
  if(!wanted) return;

  // Always canonicalize to avoid CHICKEN vs chicken duplicates
  wanted = canonicalTag(wanted);

  const parts = String(input.value || "").split(",");
  parts[parts.length - 1] = wanted;

  const normalized = normalizeList(parts.join(","));
  input.value = normalized.join(", ") + (trailingComma ? ", " : "");
}



function refreshEditSuggestions(){
  const cuisineEl = $("eCuisine");
  const dishEl    = $("eDishType");
  const equipEl   = $("eEquipment");

  const cuisineQ = lastCommaToken(cuisineEl?.value || "");
  const dishQ    = lastCommaToken(dishEl?.value || "");

  const baseEl = $("eBase");
  const ingEl  = $("eIngredient");

  const baseQ       = lastCommaToken(baseEl?.value || "");
  const ingredientQ = lastCommaToken(ingEl?.value || "");
  const equipmentQ  = lastCommaToken(equipEl?.value || "");
  const tagQ        = lastCommaToken($("eTags")?.value || "");


  // Only add a trailing ", " automatically if you're already using commas in that field
  const useCommaMode = (el)=>{
    const v = String(el?.value || "");
    return v.includes(",") || v.trim().endsWith(",");
  };

  renderSuggestChips("cuisineSuggestions", ALL_CUISINES, cuisineQ, (v)=>{
    replaceLastCommaTokenWith("eCuisine", v, { trailingComma: useCommaMode(cuisineEl) });
  });

  renderSuggestChips("dishTypeSuggestions", ALL_DISH_TYPES, dishQ, (v)=>{
    replaceLastCommaTokenWith("eDishType", v, { trailingComma: useCommaMode(dishEl) });
  });



  renderSuggestChips("baseSuggestions", ALL_BASES, baseQ, (v)=>{
    replaceLastCommaTokenWith("eBase", v, { trailingComma: useCommaMode(baseEl) });
  });

  renderSuggestChips("ingredientSuggestions", ALL_INGREDIENTS, ingredientQ, (v)=>{
    replaceLastCommaTokenWith("eIngredient", v, { trailingComma: useCommaMode(ingEl) });
  });

  renderSuggestChips("equipmentSuggestions", ALL_EQUIPMENT, equipmentQ, (v)=>{
    replaceLastCommaTokenWith("eEquipment", v); // trailing comma behavior kept
  });


  renderSuggestChips("tagSuggestions", ALL_TAGS, tagQ, (v)=>{
    replaceLastCommaTokenWith("eTags", v);       // trailing comma behavior kept
  });
}



  function setStatus(msg){ $("status").textContent = msg ? ("— " + msg) : ""; }
  function toast(msg){ setStatus(msg); setTimeout(()=>setStatus(""), 1200); }

  function setSyncBadge(mode, text){
  const el = $("syncBadge");
  if(!el) return;

  // mode: "ok" | "warn" | "bad" | "" (neutral)
  el.classList.remove("ok","warn","bad");
  if(mode) el.classList.add(mode);

  const label = text || "";
  el.innerHTML = `<span class="syncDot"></span>${escapeHtml(label)}`;
}

function setCloudStatus(){
  const el = $("cloud");
  if(!el) return;

  const on = !!(window.FB && window.FB.enabled);
  el.textContent = on
    ? `cloud: yes • recipes: ${state.recipes.length}`
    : `cloud: no • recipes: ${state.recipes.length}`;

  // Update badge from current conditions
  const user = window._getCurrentUser ? window._getCurrentUser() : null;

  if(!user){
    setSyncBadge("", "Signed out");
    return;
  }

  if(!navigator.onLine){
    setSyncBadge("warn", "Offline (using cache)");
    return;
  }

  // default signed-in online state
  setSyncBadge("ok", "Synced");
}





  // Snackbar (Undo)
  let snackTimer = null;
  let undoFn = null;

  function showSnack(message, onUndo){
    $("snackMsg").textContent = message;
    undoFn = onUndo || null;

    const btn = $("snackUndo");
    btn.style.display = undoFn ? "" : "none";

    $("snack").classList.add("show");
    if(snackTimer) clearTimeout(snackTimer);
    snackTimer = setTimeout(hideSnack, 5000);
  }

  function hideSnack(){
    $("snack").classList.remove("show");
    undoFn = null;
    if(snackTimer) clearTimeout(snackTimer);
    snackTimer = null;
  }

  let fbSyncTimer = null;
let lastSyncAt = 0;

function scheduleFirebaseSync(){
  if(!window.FB || !window.FB.enabled) return;

  const user = window._getCurrentUser ? window._getCurrentUser() : null;
  if(!user) return;
  if(!navigator.onLine) return;

  if(fbSyncTimer) clearTimeout(fbSyncTimer);

  // show "syncing" quickly after an edit
  setSyncBadge("warn", "Syncing…");

  fbSyncTimer = setTimeout(async ()=>{
    try{
      await window.FB.syncAll(state.recipes);
      lastSyncAt = Date.now();
      setSyncBadge("ok", "Synced");
      const b = document.getElementById("syncBadge");
      if(b) b.title = `Last sync: ${new Date(lastSyncAt).toLocaleString()}`;
    }catch(e){
      console.warn("Firebase sync failed", e);
      toast("cloud sync failed");
      setSyncBadge("warn", "Sync failed");
    }
  }, 800);
}



function saveLocal(opts={}){
  localStorage.setItem(LS_KEY, JSON.stringify(state.recipes));
  rebuildTagCaches();
  refreshEditSuggestions();

  if(!opts.skipCloud) scheduleFirebaseSync();
}


  function loadLocal(){
    const raw = localStorage.getItem(LS_KEY);
    if(!raw) return null;
    try{ const data = JSON.parse(raw); return Array.isArray(data)?data:null; }catch{return null;}
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }

    // Cook Mode + Wake Lock (keep screen awake when supported)
  const COOKMODE_KEY = "rv.cookMode.v1";
  let wakeLockSentinel = null;

  function cookModeEnabled(){
    return document.body.classList.contains("cookMode");
  }

  async function requestWakeLock(){
    try{
      if(!("wakeLock" in navigator)) return false;
      wakeLockSentinel = await navigator.wakeLock.request("screen");
      return true;
    }catch{
      wakeLockSentinel = null;
      return false;
    }
  }

  async function releaseWakeLock(){
    try{
      if(wakeLockSentinel){
        await wakeLockSentinel.release();
        wakeLockSentinel = null;
      }
    }catch{}
  }

  async function updateCookModeUI(){
    const btn = $("cookModeBtn");
    const hint = $("wakeHint");
    const on = cookModeEnabled();

    if(btn) btn.textContent = on ? "Cook Mode: On" : "Cook Mode";

    if(!hint) return;

    const viewerOpen = $("viewer").classList.contains("show");
    if(on && !viewerOpen){
      hint.style.display = "none";
      hint.textContent = "";
      return;
    }

    if(!on){
      hint.style.display = "none";
      hint.textContent = "";
      await releaseWakeLock();
      return;
    }

    hint.style.display = "";
    hint.textContent = "Tip: keeping your screen awake while cooking…";

    const ok = await requestWakeLock();
    hint.textContent = ok
      ? "Screen awake: enabled (if supported)."
      : "Tip: set your phone's Screen Timeout longer while cooking.";
  }

  function setCookMode(on){
    document.body.classList.toggle("cookMode", !!on);
    localStorage.setItem(COOKMODE_KEY, on ? "1" : "0");
    updateCookModeUI();
  }

  document.addEventListener("visibilitychange", ()=>{
    if(document.visibilityState === "visible" && cookModeEnabled()){
      requestWakeLock();
    }
  });


  function refreshFilterOptions(){
    const cuisines = Array.from(new Set(
      state.recipes.flatMap(r => toList(r.cuisine).map(x=>String(x||"").trim()).filter(Boolean))
    )).sort();

    const equipment = Array.from(new Set(
      state.recipes.flatMap(r => toList(r.equipment).map(x=>String(x||"").trim()).filter(Boolean))
    )).sort();

    const dishTypes = Array.from(new Set(
      state.recipes.flatMap(r => toList(r.dishType).map(x=>String(x||"").trim()).filter(Boolean))
    )).sort();

const bases = Array.from(new Set(
  state.recipes.flatMap(r => toList(r.base).map(x=>String(x||"").trim()).filter(Boolean))
)).sort();

const ingredients = Array.from(new Set(
  state.recipes.flatMap(r => toList(r.mainIngredient).map(x=>String(x||"").trim()).filter(Boolean))
)).sort();

    const tags = Array.from(new Set(state.recipes.flatMap(r => r.tags||[]).map(t=>String(t||"").trim()).filter(Boolean))).sort();

    const c = $("cuisineF"), eq = $("equipmentF");
    const dt = $("dishTypeF"), b = $("baseF"), ing = $("ingredientF"), tag = $("tagF");

    const cv=c?.value||"", eqv=eq?.value||"", dtv=dt?.value||"", bv=b?.value||"", ingv=ing?.value||"", tagv=tag?.value||"";



    if(c) c.innerHTML = `<option value="">Any</option>` + cuisines.map(x=>`<option>${escapeHtml(x)}</option>`).join("");
    if(eq) eq.innerHTML = `<option value="">Any</option>` + equipment.map(x=>`<option>${escapeHtml(x)}</option>`).join("");
    if(dt) dt.innerHTML = `<option value="">Any</option>` + dishTypes.map(x=>`<option>${escapeHtml(x)}</option>`).join("");

    if(b) b.innerHTML = `<option value="">Any</option>` + bases.map(x=>`<option>${escapeHtml(x)}</option>`).join("");
    if(ing) ing.innerHTML = `<option value="">Any</option>` + ingredients.map(x=>`<option>${escapeHtml(x)}</option>`).join("");
    if(tag) tag.innerHTML = `<option value="">Any</option>` + tags.map(x=>`<option>${escapeHtml(x)}</option>`).join("");

    if(c && cuisines.includes(cv)) c.value=cv;
    if(eq && equipment.includes(eqv)) eq.value=eqv;
    if(dt && dishTypes.includes(dtv)) dt.value=dtv;

    if(b && bases.includes(bv)) b.value=bv;
    if(ing && ingredients.includes(ingv)) ing.value=ingv;
    if(tag && tags.includes(tagv)) tag.value=tagv;
  }


  function hay(r){
    return [
      r.title, r.cuisine, r.dishType, r.base, r.mainIngredient,
      (toList(r.equipment)||[]).join(" "),
      (toList(r.tags)||[]).join(" "),
      r.ingredients, r.directions, r.notes
    ].join("\n").toLowerCase();
  }



  function filtered(){
    const q = $("q").value.trim().toLowerCase();
    const cuisine = ($("cuisineF").value || "").trim().toLowerCase();
    const equipment = ($("equipmentF").value || "").trim().toLowerCase();
    const dishType = $("dishTypeF")?.value || "";

    const base = $("baseF")?.value || "";
    const ingredient = $("ingredientF")?.value || "";
    const tag = $("tagF")?.value || "";
    const maxTime = Number($("maxTime").value||0);


    let out = state.recipes.filter(r=>{
// Hide the special "Placeholder" recipe unless the current search text matches its title.
const titleLower = String(r.title || "").trim().toLowerCase();
const isPlaceholder = titleLower.startsWith("placeholder");

// Show it if the current query matches the title (so "place" works, not just "placeholder")
const wantsPlaceholder = !!q && titleLower.includes(q);

if(isPlaceholder && !wantsPlaceholder) return false;


if(cuisine && !toListLower(r.cuisine).includes(cuisine)) return false;
if(equipment){
        const arr = toListLower(r.equipment);
        if(!arr.includes(equipment)) return false;
      }

      if(dishType && !toList(r.dishType).includes(dishType)) return false;

if(base && !toList(r.base).includes(base)) return false;
if(ingredient && !toList(r.mainIngredient).includes(ingredient)) return false;

      if(tag && !(r.tags||[]).includes(tag)) return false;

      if(maxTime>0 && Number(r.timeMinutes||0)>maxTime) return false;
      if(q && !hay(r).includes(q)) return false;
      return true;

    });

const sort = $("sort").value;

function titleScore(r){
  if(!q) return 0;
  const t = String(r.title||"").toLowerCase();
  if(!t) return 0;
  if(t === q) return 3;
  if(t.startsWith(q)) return 2;
  if(t.includes(q)) return 1;
  return 0;
}

out.sort((a,b)=>{
  // 1) When searching, prioritize title matches
  if(q){
    const sa = titleScore(a), sb = titleScore(b);
    if(sb !== sa) return sb - sa;
  }

  // 2) Then apply your selected sort
  if(sort==="updated") return (b.updatedAt||0)-(a.updatedAt||0);
  if(sort==="title") return (a.title||"").localeCompare(b.title||"");
  if(sort==="cooked") return (Number(b.cookedCount||0)-Number(a.cookedCount||0));
  if(sort==="time") return (Number(a.timeMinutes||1e9)-Number(b.timeMinutes||1e9));
  return 0;
});

return out;

  }

  function setGridColumns(n){
    const grid = $("grid");
    grid.style.gridTemplateColumns = `repeat(${n}, minmax(0,1fr))`;
  }

  // Make slider intuitive: right = bigger cards (fewer columns)
  function applyCardSize(){
    const v = Number($("size").value); // 2..6
    let cols = (8 - v);                // 6..2 (right = bigger cards)

    // On small screens, keep cards big (never more than 2 columns)
    if(window.innerWidth <= 520) cols = Math.min(cols, 2);

    setGridColumns(cols);
  }

  function pill(txt){
    const s=document.createElement("span");
    s.className="pill"; s.textContent=txt; return s;
  }

  function renderGrid(){
    const arr = filtered();
    $("count").textContent = String(arr.length);

    const grid = $("grid");
    grid.innerHTML = "";

    if(arr.length===0){
      const div=document.createElement("div");
      div.className="hint";
      div.textContent="No matches. Clear filters or search.";
      grid.appendChild(div);
      return;
    }

    for(const r of arr){
      const tile = document.createElement("div");
      tile.className = "tile";
      tile.onclick = ()=> openViewer(r.id);

      const imgBox = document.createElement("div");
      imgBox.className = "imgBox";

      if(r.imageUrl){
        const img = document.createElement("img");
        img.alt = "";
        img.loading = "lazy";
        img.src = r.imageUrl;
        img.onerror = ()=>{
          img.remove();
          const fb = document.createElement("div");
          fb.className = "imgFallback";
          fb.textContent = "No image";
          imgBox.appendChild(fb);
        };
        imgBox.appendChild(img);
      } else {
        const fb = document.createElement("div");
        fb.className = "imgFallback";
        fb.textContent = "No image";
        imgBox.appendChild(fb);
      }

      const body = document.createElement("div");
      body.className = "tileBody";

      const title = document.createElement("div");
      title.className = "tileTitle";
      title.textContent = r.title || "(untitled)";

      const meta = document.createElement("div");
      meta.className = "tileMeta";

      if((r.cookedCount||0)>0){
        const b = document.createElement("span");
        b.className="badge pill";
        b.innerHTML = `<span class="dot"></span> cooked ${r.cookedCount}`;
        meta.appendChild(b);
      }

      // Card pill order: cuisine, equipment, time, main ingredient, course, then any other tags
      const seen = new Set();
      const addPillOnce = (v)=>{
        const s = String(v||"").trim();
        if(!s) return;
        const k = s.toLowerCase();
        if(seen.has(k)) return;
        seen.add(k);
        meta.appendChild(pill(s));
      };

      for(const c of toList(r.cuisine)) addPillOnce(c);

      const eqFirst = toList(r.equipment)[0];
      if(eqFirst) addPillOnce(eqFirst);

      if(r.timeMinutes) addPillOnce(`${r.timeMinutes}m`);

      for(const mi of toList(r.mainIngredient)) addPillOnce(mi);
      for(const b of toList(r.base)) addPillOnce(b);
      for(const dt of toList(r.dishType)) addPillOnce(dt);

      for(const t of toList(r.tags)) addPillOnce(t);





      body.appendChild(title);
      body.appendChild(meta);

      tile.appendChild(imgBox);
      tile.appendChild(body);

      grid.appendChild(tile);
    }
  }

  /* Viewer */
  function showViewer(show){
    $("overlay").classList.toggle("show", show);
    $("viewer").classList.toggle("show", show);
    $("viewer").setAttribute("aria-hidden", String(!show));
    document.body.style.overflow = show ? "hidden" : "";
  }

  function getSelected(){
    return state.recipes.find(r => r.id === state.selectedId) || null;
  }

  function openViewer(id){
    state.selectedId = id;
    state.editOpen = false;

    state.scaleFactor = 1;
    state.baseServings = null;
    $("scaleServingsTarget").value = "";

    $("editPanel").classList.remove("show");
    $("editToggleBtn").textContent = "Edit";

    renderViewer();      // computes baseServings + renders default scale
    applySavedScale();   // restores last-used scale for this recipe (if any)

    showViewer(true);

    // If Cook Mode is on, update hint + try wake lock now (user gesture is the click)
    if(cookModeEnabled()) updateCookModeUI();
  }


  function closeViewer(){
    showViewer(false);
    state.selectedId = null;
    state.editOpen = false;
    hideSnack();
    releaseWakeLock();
    const hint = $("wakeHint");
    if(hint){ hint.style.display = "none"; hint.textContent = ""; }
  }


  // Ingredients checkbox state helpers
  function checksKey(recipeId){ return CHECKS_PREFIX + recipeId; }

  function loadChecks(recipeId){
    try{
      const raw = localStorage.getItem(checksKey(recipeId));
      if(!raw) return new Set();
      const arr = JSON.parse(raw);
      if(!Array.isArray(arr)) return new Set();
      return new Set(arr);
    }catch{
      return new Set();
    }
  }

  function saveChecks(recipeId, set){
    try{
      localStorage.setItem(checksKey(recipeId), JSON.stringify(Array.from(set)));
    }catch{}
  }
// Count only real ingredient items (exclude "## " headers)
function countIngredientItems(lines){
  return (lines || []).filter(l => !String(l).startsWith("## ")).length;
}

// Update the master checkbox state based on how many items are checked
function updateToggleAllIngCb(totalCount, checkedSet){
  const cb = $("toggleAllIngCb");
  if(!cb) return;

  const total = Number(totalCount || 0);
  if(total <= 0){
    cb.disabled = true;
    cb.checked = false;
    return;
  }

  cb.disabled = false;
  const checkedN = (checkedSet instanceof Set) ? checkedSet.size : 0;
  cb.checked = (checkedN >= total);
}

// Set/clear ALL ingredient checks for the currently viewed recipe
function setAllIngredientChecks(shouldCheck){
  const r = getSelected();
  if(!r) return;

  const lines = parseIngredientLines(r.ingredients);
  const totalCount = countIngredientItems(lines);
  if(totalCount <= 0) return;

  const next = new Set();
  if(shouldCheck){
    for(let i=0;i<totalCount;i++) next.add(String(i));
  }

  saveChecks(r.id, next);
  renderIngredients(r, state.scaleFactor);
}

    // Scale persistence helpers
  function loadScaleMap(){
    try { return JSON.parse(localStorage.getItem(SCALE_STORE_KEY) || "{}") || {}; }
    catch { return {}; }
  }

  function saveScaleForRecipe(id, data){
    const map = loadScaleMap();
    map[id] = { ...(map[id] || {}), ...data, t: Date.now() };
    localStorage.setItem(SCALE_STORE_KEY, JSON.stringify(map));
  }

  function getScaleForRecipe(id){
    const map = loadScaleMap();
    return map[id] || null;
  }

  function persistCurrentScale(){
    const r = getSelected();
    if(!r) return;

    const targetEl = $("scaleServingsTarget");
    const targetVal = Number(targetEl?.value);

    if(state.baseServings && targetVal && targetVal > 0){
      saveScaleForRecipe(r.id, { targetServings: targetVal, scaleFactor: state.scaleFactor });
    } else {
      saveScaleForRecipe(r.id, { scaleFactor: state.scaleFactor });
    }
  }

  function applySavedScale(){
    const r = getSelected();
    if(!r) return;

    const saved = getScaleForRecipe(r.id);
    if(!saved) return;

    // If we have a base servings, restore target servings if present
    if(state.baseServings && saved.targetServings){
      $("scaleServingsTarget").value = String(saved.targetServings);
      state.scaleFactor = Number(saved.targetServings) / state.baseServings;
      updateScaleUI();
      renderIngredients(r, state.scaleFactor);
      persistCurrentScale();
      return;
    }

    // Otherwise restore a raw factor
    if(saved.scaleFactor){
      state.scaleFactor = Number(saved.scaleFactor) || 1;
      updateScaleUI();
      renderIngredients(r, state.scaleFactor);
      persistCurrentScale();
    }
  }


  function parseIngredientLines(text){
    const lines = (text || "").split("\n").map(l => l.trim()).filter(l => l.length>0);
    return lines;
  }

  function stripLeadingStepNumber(s){
  // Removes "12. ", "12) ", "12: ", "12 - " and also repeated duplicates like "12. 12. ..."
  return String(s || "").replace(/^\s*(?:\d+\s*[\.\)\:\-]\s+)+/, "");
}


  // -------- Smart scaling helpers --------
const UNICODE_FRACS = {
  "¼": 1/4, "½": 1/2, "¾": 3/4,
  "⅐": 1/7, "⅑": 1/9, "⅒": 1/10,
  "⅓": 1/3, "⅔": 2/3,
  "⅕": 1/5, "⅖": 2/5, "⅗": 3/5, "⅘": 4/5,
  "⅙": 1/6, "⅚": 5/6,
  "⅛": 1/8, "⅜": 3/8, "⅝": 5/8, "⅞": 7/8
};

function parseNumberToken(tok){
  if(!tok) return null;
  tok = tok.trim();
  if(UNICODE_FRACS[tok] != null) return UNICODE_FRACS[tok];

  // "1½"
  const mMix = tok.match(/^(\d+)([¼½¾⅐⅑⅒⅓⅔⅕⅖⅗⅘⅙⅚⅛⅜⅝⅞])$/);
  if(mMix) return Number(mMix[1]) + (UNICODE_FRACS[mMix[2]] || 0);

  // "1/2"
  const mFrac = tok.match(/^(\d+)\s*\/\s*(\d+)$/);
  if(mFrac){
    const a = Number(mFrac[1]), b = Number(mFrac[2]);
    if(b) return a/b;
  }

  // "1" or "1.25"
  if(/^\d+(\.\d+)?$/.test(tok)) return Number(tok);
  return null;
}

function parseLeadingQuantity(line){
  const s = line.trim();
  if(/^##\s*/.test(s)) return null; // header line

  // range: "1-2" or "1 to 2"
  const range = s.match(/^(\S+)\s*(?:-|–|—|\bto\b)\s*(\S+)(.*)$/i);
  if(range){
    const a = parseNumberToken(range[1]);
    const b = parseNumberToken(range[2]);
    if(a != null && b != null){
      return { isRange:true, a, b, rest:(range[3]||"").trimStart() };
    }
  }

  // mixed: "1 1/2"
  const mixed = s.match(/^(\d+)\s+(\S+)(.*)$/);
  if(mixed){
    const a = Number(mixed[1]);
    const b = parseNumberToken(mixed[2]);
    if(!Number.isNaN(a) && b != null){
      return { isRange:false, v:a+b, rest:(mixed[3]||"").trimStart() };
    }
  }

  // single: "½" or "1/2" or "2"
  const single = s.match(/^(\S+)(.*)$/);
  if(single){
    const v = parseNumberToken(single[1]);
    if(v != null) return { isRange:false, v, rest:(single[2]||"").trimStart() };
  }

  return null;
}

function formatNumberSmart(n){
  if(Math.abs(n - Math.round(n)) < 0.01) return String(Math.round(n));
  // try common fraction denominators
  const dens = [2,3,4,5,6,8,10,12,16];
  const sign = n < 0 ? -1 : 1;
  n = Math.abs(n);
  const whole = Math.floor(n + 1e-9);
  const frac = n - whole;

  let best = null;
  for(const d of dens){
    const num = Math.round(frac * d);
    const approx = num / d;
    const err = Math.abs(frac - approx);
    if(best == null || err < best.err) best = { num, d, err };
  }
  if(best && best.num !== 0 && best.err < 0.02){
    // reduce fraction
    const gcd = (a,b)=> b ? gcd(b, a%b) : a;
    let num = best.num, den = best.d;
    const g = gcd(num, den);
    num /= g; den /= g;
    const out = whole ? `${whole} ${num}/${den}` : `${num}/${den}`;
    return sign < 0 ? `-${out}` : out;
  }
  const dec = (sign * (whole + frac)).toFixed(2).replace(/\.00$/,"").replace(/(\.\d)0$/,"$1");
  return dec;
}

function parseQuantityAnywhere(line){
  const s = String(line || "");
  if(/^##\s*/.test(s.trim())) return null; // header line

  // Token that parseNumberToken() understands: 2, 1.5, 1/2, ½, 1½, etc.
  const TOK = "(?:\\d+(?:\\.\\d+)?|\\d+\\s*\\/\\s*\\d+|[¼½¾⅐⅑⅒⅓⅔⅕⅖⅗⅘⅙⅚⅛⅜⅝⅞]|\\d+[¼½¾⅐⅑⅒⅓⅔⅕⅖⅗⅘⅙⅚⅛⅜⅝⅞])";

  // Range anywhere: "... 1-2 ..." or "... 1 to 2 ..."
  const reRange = new RegExp(`^(.*?)(`+TOK+`)\\s*(?:([\\-–—])|\\b(to)\\b)\\s*(`+TOK+`)(.*)$`, "i");
  const mR = s.match(reRange);
  if(mR){
    const a = parseNumberToken(mR[2].replace(/\s+/g,""));
    const b = parseNumberToken(mR[5].replace(/\s+/g,""));
    if(a != null && b != null){
      const pre = mR[1] || "";
      const post = mR[6] || "";
      const sep = mR[3] ? mR[3] : (mR[4] ? " to " : "-");
      return { isRange:true, a, b, pre, post, sep };
    }
  }

  // Mixed anywhere: "... 1 1/2 ..."
  const reMixed = new RegExp(`^(.*?)(\\d+)\\s+(`+TOK+`)(.*)$`);
  const mM = s.match(reMixed);
  if(mM){
    const whole = Number(mM[2]);
    const frac = parseNumberToken(mM[3].replace(/\s+/g,""));
    if(!Number.isNaN(whole) && frac != null){
      return { isRange:false, v: whole + frac, pre: mM[1] || "", post: mM[4] || "" };
    }
  }

  // Single token anywhere: "... 1/2 ..."
  const reSingle = new RegExp(`^(.*?)(`+TOK+`)(.*)$`);
  const mS = s.match(reSingle);
  if(mS){
    const v = parseNumberToken(mS[2].replace(/\s+/g,""));
    if(v != null){
      return { isRange:false, v, pre: mS[1] || "", post: mS[3] || "" };
    }
  }

  return null;
}

function scaleIngredientLine(line, factor){
  if(!factor || Math.abs(factor - 1) < 1e-9) return line;

  // Prefer the “leading quantity” behavior (best formatting for normal lines)
  const pLead = parseLeadingQuantity(line);
  if(pLead){
    if(pLead.isRange){
      return `${formatNumberSmart(pLead.a*factor)}-${formatNumberSmart(pLead.b*factor)} ${pLead.rest}`.trim();
    }
    return `${formatNumberSmart(pLead.v*factor)} ${pLead.rest}`.trim();
  }

  // Safety: don't scale temps or times even if they appear in ingredients text
  const lower = String(line||"").toLowerCase();
  const hasTemp = /(?:°\s*[fc]|degrees?\s*[fc]|\b(fahrenheit|celsius)\b)/i.test(line);
  const hasTime = /\b(sec|secs|second|seconds|min|mins|minute|minutes|hr|hrs|hour|hours)\b/i.test(lower);
  if(hasTemp || hasTime) return line;

  // Fallback: scale the first quantity anywhere in the line
  const pAny = parseQuantityAnywhere(line);
  if(!pAny) return line;


  if(pAny.isRange){
    return `${pAny.pre}${formatNumberSmart(pAny.a*factor)}${pAny.sep}${formatNumberSmart(pAny.b*factor)}${pAny.post}`.trim();
  }
  return `${pAny.pre}${formatNumberSmart(pAny.v*factor)}${pAny.post}`.trim();
}


function parseFirstNumberAnywhere(text){
  if(!text) return null;
  const m = String(text).match(/(\d+(\.\d+)?|\d+\s*\/\s*\d+|[¼½¾⅐⅑⅒⅓⅔⅕⅖⅗⅘⅙⅚⅛⅜⅝⅞])/);
  if(!m) return null;
  return parseNumberToken(m[1].replace(/\s+/g,""));
}


  function renderIngredients(r, factor = 1){
    const host = $("vIngredients");
    host.innerHTML = "";

    const lines = parseIngredientLines(r.ingredients);
    if(lines.length === 0){
      const empty = document.createElement("div");
      empty.className = "hint";
      empty.textContent = "No ingredients yet.";
      host.appendChild(empty);
      return;
    }

    const totalCount = countIngredientItems(lines);

    // Load + clean checked set so it matches current ingredient count
    const rawChecked = loadChecks(r.id);
    const checked = new Set(Array.from(rawChecked).filter(k=>{
      const n = Number(k);
      return Number.isFinite(n) && n >= 0 && n < totalCount;
    }));
    if(checked.size !== rawChecked.size) saveChecks(r.id, checked);

    let itemIndex = 0;


    const ul = document.createElement("div");
    ul.className = "ingList";

    for(const line of lines){
      if(line.startsWith("## ")){
        const hdr = document.createElement("div");
        hdr.className = "ingHeader";
        hdr.textContent = line.replace(/^##\s*/, "");
        ul.appendChild(hdr);
        continue;
      }

      const row = document.createElement("label");
      row.className = "ingItem";

      const cb = document.createElement("input");
      cb.type = "checkbox";
      const key = String(itemIndex);
      cb.checked = checked.has(key);

      const txt = document.createElement("div");
      txt.className = "ingText" + (cb.checked ? " checked" : "");
      txt.textContent = scaleIngredientLine(line, factor);


      cb.addEventListener("change", ()=>{
        const set = new Set(loadChecks(r.id));
        if(cb.checked) set.add(key);
        else set.delete(key);

        // keep only valid keys (0..totalCount-1)
        const cleaned = new Set(Array.from(set).filter(k=>{
          const n = Number(k);
          return Number.isFinite(n) && n >= 0 && n < totalCount;
        }));

        saveChecks(r.id, cleaned);
        txt.classList.toggle("checked", cb.checked);

        // keep master checkbox in sync
        updateToggleAllIngCb(totalCount, cleaned);
      });



      row.appendChild(cb);
      row.appendChild(txt);
      ul.appendChild(row);

      itemIndex++;
    }

    host.appendChild(ul);
    updateToggleAllIngCb(totalCount, checked);

  }

  function renderViewer(){
    const r = getSelected();
    if(!r) return;

    $("vTitle").textContent = r.title || "(untitled)";

    const subBits = [];
    if(r.cuisine) subBits.push(r.cuisine);
    if(r.timeMinutes) subBits.push(`${r.timeMinutes} min`);
    if(r.servings) subBits.push(r.servings);
    $("vSub").textContent = subBits.join(" • ");

    // Hero image
    if(r.imageUrl){
      $("vHero").style.display = "";
      $("vImg").src = r.imageUrl;
    } else {
      $("vHero").style.display = "none";
      $("vImg").removeAttribute("src");
    }

    // Quick info pills
    const info = $("vInfo");
    info.innerHTML = "";
    if(toList(r.dishType).length) info.appendChild(pill("dish type: " + listToDisplay(r.dishType)));
    if(toList(r.mainIngredient).length) info.appendChild(pill("ingredient: " + listToDisplay(r.mainIngredient)));
    if(toList(r.base).length) info.appendChild(pill("base: " + listToDisplay(r.base)));
    if(toList(r.equipment).length) info.appendChild(pill("equipment: " + listToDisplay(r.equipment)));



    if(r.dishesCount != null) info.appendChild(pill("dishes: " + r.dishesCount));
    if((r.tags||[]).length) info.appendChild(pill("tags: " + r.tags.join(", ")));
    if((r.cookedCount||0)>0) info.appendChild(pill("cooked: " + r.cookedCount));

    $("vSource").innerHTML = r.sourceUrl
      ? `Source: <a href="${escapeHtml(r.sourceUrl)}" target="_blank" rel="noreferrer">${escapeHtml(r.sourceUrl)}</a>`
      : `<span class="muted">No source URL</span>`;

    state.baseServings = parseFirstNumberAnywhere(r.servings);
    updateScaleUI();
    renderIngredients(r, state.scaleFactor);



    $("vDirections").textContent = r.directions || "";

    if(r.notes && r.notes.trim()){
      $("vNotesWrap").style.display = "";
      $("vNotes").textContent = r.notes;
    } else {
      $("vNotesWrap").style.display = "none";
    }

    if(state.editOpen) fillEditForm(r);
  }

  function updateScaleUI(){
    const r = getSelected();
    if(!r) return;

    const row = $("scaleServingsRow");
    const baseEl = $("scaleServingsBase");
    const targetEl = $("scaleServingsTarget");
    const meta = $("scaleMeta");
    const resetBtn = $("scaleReset");

    const base = state.baseServings;

    if(base && base > 0){
      row.style.display = "";
      baseEl.textContent = formatNumberSmart(base);

      // Default target to base if empty
      const t = Number(targetEl.value);
      const target = (t && t > 0) ? t : base;
      if(!(t && t > 0)) targetEl.value = String(base);

      state.scaleFactor = target / base;

      resetBtn.textContent = `${formatNumberSmart(state.scaleFactor)}×`;
      meta.textContent = `Scaled to ${formatNumberSmart(target)} servings (${formatNumberSmart(state.scaleFactor)}×)`;
    } else {
      row.style.display = "none";
      resetBtn.textContent = `${formatNumberSmart(state.scaleFactor)}×`;
      meta.textContent = `Scale: ${formatNumberSmart(state.scaleFactor)}×`;
    }
  }

  function setEditImagePreview(url){
  const img = $("eImagePreview");
  const rm = $("removeImageBtn");
  if(!img) return;

  if(url){
    img.src = url;
    img.style.display = "block";
    if(rm) rm.style.display = "";
  }else{
    img.removeAttribute("src");
    img.style.display = "none";
    if(rm) rm.style.display = "none";
  }
}

async function compressImageFile(file, maxDim=1600, quality=0.72){
  // If it’s already small, don’t bother
  const maxBytes = 900 * 1024; // ~0.9MB target before we stop trying
  if(file.size <= maxBytes) return file;

  const img = await new Promise((res, rej)=>{
    const i = new Image();
    i.onload = ()=> res(i);
    i.onerror = rej;
    i.src = URL.createObjectURL(file);
  });

  const w = img.naturalWidth || img.width;
  const h = img.naturalHeight || img.height;
  const scale = Math.min(1, maxDim / Math.max(w,h));
  const nw = Math.max(1, Math.round(w * scale));
  const nh = Math.max(1, Math.round(h * scale));

  const canvas = document.createElement("canvas");
  canvas.width = nw; canvas.height = nh;
  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0, nw, nh);

  URL.revokeObjectURL(img.src);

  const blob = await new Promise(res=> canvas.toBlob(res, "image/jpeg", quality));
  if(!blob) return file;

  // return as a File so it behaves like an uploadable file
  return new File([blob], "recipe.jpg", { type: "image/jpeg" });
}


  /* Editing (only on demand) */
  function fillEditForm(r){
    $("eTitle").value = r.title || "";
    $("eCuisine").value = listToDisplay(r.cuisine);
    $("eDishType").value = listToDisplay(r.dishType);

    $("eBase").value = listToDisplay(r.base);
    $("eIngredient").value = listToDisplay(r.mainIngredient);

    $("eEquipment").value = listToDisplay(r.equipment);
    $("eTime").value = r.timeMinutes ?? "";
    $("eDishes").value = r.dishesCount ?? "";
    $("eTags").value = listToDisplay(r.tags);

    $("eImageUrl").value = r.imageUrl || "";
    if($("eImagePath")) $("eImagePath").value = r.imagePath || "";
    setEditImagePreview(r.imageUrl || "");

    $("eSourceUrl").value = r.sourceUrl || "";
    $("eServings").value = r.servings || "";
    $("eIngredients").value = r.ingredients || "";
    $("eDirections").value = r.directions || "";
    $("eNotes").value = r.notes || "";
    $("eCookedCount").value = Number(r.cookedCount||0);

    const parts = [
      `Updated: ${new Date(r.updatedAt||r.createdAt).toLocaleString()}`,
      `Cooked: ${r.cookedCount||0}`,
      r.lastCookedAt ? `Last cooked: ${new Date(r.lastCookedAt).toLocaleString()}` : ""
    ].filter(Boolean);
    $("editStats").textContent = parts.join(" • ");

    refreshEditSuggestions();

  }

  function toggleEdit(){
    const r = getSelected();
    if(!r) return;

    state.editOpen = !state.editOpen;
    $("editPanel").classList.toggle("show", state.editOpen);
    $("editToggleBtn").textContent = state.editOpen ? "Close edit" : "Edit";

    if(state.editOpen){
      fillEditForm(r);
      setTimeout(()=> $("editPanel").scrollIntoView({behavior:"smooth", block:"start"}), 50);
    }
  }

  function saveEdit(){
    const r = getSelected();
    if(!r) return;
    const idx = state.recipes.findIndex(x=>x.id===r.id);
    if(idx<0) return;

    const t = Date.now();
    const cookedCount = Math.max(0, Number($("eCookedCount").value || 0));

    const updated = {
      ...state.recipes[idx],
      title: ($("eTitle").value.trim() || "(untitled)"),
      cuisine: canonicalList($("eCuisine").value),
      dishType: canonicalList($("eDishType").value),
      base: canonicalList($("eBase").value),
      mainIngredient: canonicalList($("eIngredient").value),
      equipment: canonicalList($("eEquipment").value),
      timeMinutes: $("eTime").value ? Number($("eTime").value) : null,
      dishesCount: $("eDishes").value ? Number($("eDishes").value) : null,
      tags: canonicalList($("eTags").value),

      imageUrl: $("eImageUrl").value.trim(),
      imagePath: $("eImagePath") ? $("eImagePath").value.trim() : (state.recipes[idx].imagePath || ""),

      sourceUrl: $("eSourceUrl").value.trim(),
      servings: $("eServings").value.trim(),
      ingredients: $("eIngredients").value.trim(),
      directions: $("eDirections").value.trim(),
      notes: $("eNotes").value.trim(),
      cookedCount: cookedCount,
      updatedAt: t
    };

    state.recipes[idx] = updated;
    saveLocal();
    refreshFilterOptions();
    renderGrid();
    renderViewer();
    refreshEditSuggestions();
    toast("saved locally");

  }

  // Cooked +1 with cooldown + Undo snackbar
  function markCooked(){
    const r = getSelected();
    if(!r) return;
    const idx = state.recipes.findIndex(x=>x.id===r.id);
    if(idx<0) return;

    const btn = $("markCookedBtn");
    if(btn.disabled) return; // prevent stacking
    btn.disabled = true;
    setTimeout(()=>btn.disabled=false, 1500);

    const t = Date.now();
    state.recipes[idx].cookedCount = Number(state.recipes[idx].cookedCount||0) + 1;
    state.recipes[idx].lastCookedAt = t;
    state.recipes[idx].updatedAt = t;
    saveLocal();
    renderGrid();
    renderViewer();

    showSnack("Cooked +1", () => {
      const j = state.recipes.findIndex(x=>x.id===r.id);
      if(j<0) return;
      state.recipes[j].cookedCount = Math.max(0, Number(state.recipes[j].cookedCount||0) - 1);
      state.recipes[j].updatedAt = Date.now();
      saveLocal();
      renderGrid();
      renderViewer();
      toast("undid cooked");
    });
  }

  function deleteRecipe(){
    const r = getSelected();
    if(!r) return;
    if(!confirm(`Delete "${r.title}"?`)) return;
    state.recipes = state.recipes.filter(x=>x.id!==r.id);
    saveLocal();
    refreshFilterOptions();
    renderGrid();
    toast("deleted");
    closeViewer();
  }

  function newRecipe(){
    const t = Date.now();
    const r = {
      id: uid(),
      title: "New Recipe",
      cuisine: "",
      dishType: "",
      base: "",
      mainIngredient: "",
      equipment: [],
      timeMinutes: null,

      dishesCount: null,
      tags: [],
      cookedCount: 0,
      lastCookedAt: null,
      createdAt: t,
      updatedAt: t,
      imageUrl: "",
      sourceUrl: "",
      servings: "",
      ingredients: "",
      directions: "",
      notes: ""
    };
    state.recipes.unshift(r);
    saveLocal();
    refreshFilterOptions();
    renderGrid();
    openViewer(r.id);
    state.editOpen = true;
    $("editPanel").classList.add("show");
    $("editToggleBtn").textContent = "Close edit";
    fillEditForm(r);
    toast("new recipe");
  }

  /* Download a single-recipe offline page */
  function sanitizeFileName(s){
    return (s || "recipe").toLowerCase()
      .replace(/[^a-z0-9]+/g, "_")
      .replace(/^_+|_+$/g, "")
      .slice(0, 60) || "recipe";
  }

  function recipeToStandaloneHTML(r, factor = 1){
    const title = escapeHtml(r.title || "Recipe");

    // Absolute image URL so the downloaded HTML can still load images while online
    const imgUrl = r.imageUrl ? new URL(r.imageUrl, location.href).toString() : "";
    const img = imgUrl ? `<img src="${escapeHtml(imgUrl)}" alt="" />` : "";

    const source = r.sourceUrl
      ? `<p class="muted">Source: <a href="${escapeHtml(r.sourceUrl)}" target="_blank" rel="noreferrer">${escapeHtml(r.sourceUrl)}</a></p>`
      : "";

    const infoBits = [];
    if(toList(r.cuisine).length) infoBits.push(escapeHtml(listToDisplay(r.cuisine)));
    if(toList(r.dishType).length) infoBits.push(`Dish type: ${escapeHtml(listToDisplay(r.dishType))}`);
    if(r.timeMinutes) infoBits.push(`${Number(r.timeMinutes)} min`);
    if(r.servings) infoBits.push(escapeHtml(r.servings));
    if(Math.abs((factor||1) - 1) > 1e-9) infoBits.push(`Scaled: ${escapeHtml(formatNumberSmart(factor))}×`);
    if(toList(r.equipment).length) infoBits.push(`Equipment: ${escapeHtml(listToDisplay(r.equipment))}`);
    if(toList(r.tags).length) infoBits.push(`Tags: ${escapeHtml(listToDisplay(r.tags))}`);

    const info = infoBits.length ? `<div class="meta">${infoBits.join(" • ")}</div>` : "";

    function ingredientsHTML(){
      const lines = parseIngredientLines(r.ingredients || "");
      if(lines.length === 0) return `<div class="muted">No ingredients yet.</div>`;

      let out = `<ul>`;
      for(const line of lines){
        if(line.startsWith("## ")){
          out += `</ul><h3>${escapeHtml(line.replace(/^##\\s*/, ""))}</h3><ul>`;
          continue;
        }
        out += `<li>${escapeHtml(scaleIngredientLine(line, factor))}</li>`;
      }
      out += `</ul>`;
      return out;
    }

    function directionsHTML(){
      const lines = parseIngredientLines(r.directions || "");
      if(lines.length === 0) return `<div class="muted">No directions yet.</div>`;

      let out = `<ol>`;
      for(const line of lines){
        if(line.startsWith("## ")){
          out += `</ol><h3>${escapeHtml(line.replace(/^##\\s*/, ""))}</h3><ol>`;
          continue;
        }
        out += `<li>${escapeHtml(stripLeadingStepNumber(line))}</li>`;
      }
      out += `</ol>`;
      return out;
    }

    const notesHTML = (r.notes && r.notes.trim())
      ? `<div class="sec"><div class="pad"><h2>Notes</h2><pre>${escapeHtml(r.notes)}</pre></div></div>`
      : "";

    return `<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>${title}</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;margin:0;background:#0b0c10;color:#eef2ff;padding:16px}
  .card{max-width:900px;margin:0 auto;background:#12141b;border:1px solid rgba(255,255,255,.12);border-radius:16px;overflow:hidden}
  .pad{padding:14px}
  h1{margin:0;font-size:20px}
  .meta{margin-top:8px;color:rgba(238,242,255,.72);font-size:12px;line-height:1.4}
  img{width:100%;display:block;max-height:420px;object-fit:cover}
  h2{font-size:14px;margin:0}
  h3{font-size:13px;margin:14px 0 8px}
  .sec{margin-top:12px;border-top:1px solid rgba(255,255,255,.10)}
  .sec .pad{padding-top:12px}
  ul,ol{margin:10px 0 0; padding-left:20px}
  li{margin:6px 0; line-height:1.5}
  pre{white-space:pre-wrap;line-height:1.55;font-size:14px;margin:8px 0 0}
  .muted{color:rgba(238,242,255,.65);font-size:12px}
  .btnbar{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
  button{border:1px solid rgba(255,255,255,.14);background:#171a23;color:#eef2ff;padding:10px 12px;border-radius:12px;font-weight:800;cursor:pointer}
  @media print{ .btnbar{display:none} body{padding:0} .card{border:none;border-radius:0} }
</style>
</head>
<body>
  <div class="card">
    ${img}
    <div class="pad">
      <h1>${title}</h1>
      ${info}
      ${source}
      <div class="btnbar">
        <button onclick="window.print()">Print</button>
      </div>
      <p class="muted">Tip: save this file and open it anytime. Images will load while online (linked to your hosted site).</p>
    </div>
    <div class="sec"><div class="pad"><h2>Ingredients</h2>${ingredientsHTML()}</div></div>
    <div class="sec"><div class="pad"><h2>Directions</h2>${directionsHTML()}</div></div>
    ${notesHTML}
  </div>
</body>
</html>`;
  }

function recipeToPrintHTML(r, factor = 1){
  const title = escapeHtml(r.title || "Recipe");

  const infoBits = [];
  if(r.cuisine) infoBits.push(escapeHtml(r.cuisine));
  if(r.timeMinutes) infoBits.push(`${Number(r.timeMinutes)} min`);
  if(r.servings) infoBits.push(escapeHtml(r.servings));
  if(Math.abs((factor||1) - 1) > 1e-9) infoBits.push(`Scaled: ${escapeHtml(formatNumberSmart(factor))}×`);
  const info = infoBits.length ? `<div class="meta">${infoBits.join(" • ")}</div>` : "";

  function ingredientsHTML(){
    const lines = parseIngredientLines(r.ingredients || "");
    if(lines.length === 0) return `<div class="muted">—</div>`;
    const lis = lines.map(line => {
      const scaled = scaleIngredientLine(line, factor);
      return `<li>${escapeHtml(scaled)}</li>`;
    }).join("");
    return `<ul class="list">${lis}</ul>`;
  }

  function directionsHTML(){
    const lines = parseIngredientLines(r.directions || r.instructions || "");
    if(lines.length === 0) return `<div class="muted">—</div>`;

    let out = `<ol class="steps">`;
    for(const line of lines){
      if(line.startsWith("## ")){
        out += `</ol><h3>${escapeHtml(line.replace(/^##\\s*/, ""))}</h3><ol class="steps">`;
        continue;
      }
      out += `<li>${escapeHtml(stripLeadingStepNumber(line))}</li>`;
    }
    out += `</ol>`;
    return out;
  }

  const notes = (r.notes || "").trim();
  const notesHTML = notes
    ? `<div class="notes"><h2>Notes</h2><div class="noteText">${escapeHtml(notes).replace(/\n/g,"<br>")}</div></div>`
    : "";

  return `<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>${title}</title>
<style>
  :root{ color-scheme: light; }
  html, body{ margin:0; padding:0; background:#fff; color:#000; }
  body{
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    line-height: 1.22;
    font-size: 10.5pt; /* smaller to fit more */
  }

  .page{ padding: 14px 14px 16px; }

  h1{
    margin: 0 0 6px;
    font-size: 16pt;
    line-height: 1.1;
  }

  .meta{
    margin: 0 0 10px;
    font-size: 10pt;
  }

  /* Single-column stack: Ingredients then Directions (no grid gaps) */
  .stack{ display:block; }

  .box{
    border: 1px solid #000;
    border-radius: 10px;
    padding: 10px 10px 8px;
    margin: 0 0 10px;
  }

  h2{ margin: 0 0 6px; font-size: 12pt; }
  h3{ margin: 10px 0 6px; font-size: 11pt; }

  .list{ margin: 0; padding-left: 16px; }
  .list li{ margin: 0 0 3px; }

  .steps{ margin: 0; padding-left: 18px; }
  .steps li{ margin: 0 0 5px; }

  .notes{ margin-top: 10px; }
  .noteText{ font-size: 10pt; }

  .muted{ color:#000; }

  /* IMPORTANT: allow natural flowing across pages (prevents giant gaps) */
  .box, .notes, li{ break-inside: auto; page-break-inside: auto; }
  h1, h2, h3{ break-after: avoid; page-break-after: avoid; }

  /* Print rules */
  @page { margin: 0.45in; }
  @media print{
    .page{ padding: 0; }
    a{ color:#000; text-decoration:none; }
  }
</style>
</head>
<body>
  <div class="page">
    <h1>${title}</h1>
    ${info}

    <div class="stack">
      <div class="box">
        <h2>Ingredients</h2>
        ${ingredientsHTML()}
      </div>

      <div class="box">
        <h2>Directions</h2>
        ${directionsHTML()}
      </div>
    </div>

    ${notesHTML}
  </div>
</body>
</html>`;
}




  function downloadOne(){
    const r = getSelected();
    if(!r) return;
    const html = recipeToStandaloneHTML(r, state.scaleFactor || 1);

    const blob = new Blob([html], {type:"text/html"});
    const url = URL.createObjectURL(blob);
    // iPhone/iPad Safari often blocks automatic downloads.
// Fallback: open the file in a new tab so user can Share → Save to Files.
const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
if(isIOS){
  window.open(url, "_blank");
  toast("Opened recipe card — use Share → Save to Files");
  return;
}

    const a = document.createElement("a");
    a.href = url;
    a.download = sanitizeFileName(r.title) + ".html";
    a.click();
setTimeout(()=>URL.revokeObjectURL(url), 60000);

    toast("downloaded recipe page");
  }


function printCard(){
  const r = getSelected(); 
  if(!r) return;

  const html = recipeToPrintHTML(r, state.scaleFactor || 1);


  const blob = new Blob([html], {type:"text/html;charset=utf-8"});
  const url = URL.createObjectURL(blob);

  const w = window.open(url, "_blank");
  if(!w){
    toast("Popup blocked — allow popups to print");
    return;
  }

  // Try to trigger print after it loads (some iOS browsers may block auto-print)
  const t = setInterval(()=>{
    try{
      if(w.document && w.document.readyState === "complete"){
        clearInterval(t);
        setTimeout(()=>{
          w.focus();
          try{ w.print(); }catch(e){}
          toast("opened print card");
        }, 250);
      }
    }catch(e){
      clearInterval(t);
    }
  }, 100);

  setTimeout(()=>URL.revokeObjectURL(url), 60000);
}



  /* Groceries export (Apple Reminders-friendly) */
  function groceriesLines(r){
    const lines = parseIngredientLines(r.ingredients)
      .filter(l => !l.startsWith("## "))
      .map(l => l.replace(/^[-*•]\s+/, "").trim())
      .filter(Boolean);
    return lines;
  }

  async function copyGroceries(){
    const r = getSelected();
    if(!r) return;
    const lines = groceriesLines(r);
    const text = lines.join("\n");
    if(!text){
      toast("no ingredients to copy");
      return;
    }
    try{
      await navigator.clipboard.writeText(text);
      toast("copied groceries");
      showSnack("Copied ingredients (paste into Reminders)", null);
    }catch{
      // fallback: prompt
      window.prompt("Copy groceries:", text);
    }
  }

  function downloadGroceriesTxt(){
    const r = getSelected();
    if(!r) return;
    const lines = groceriesLines(r);
    const text = lines.join("\n");
    if(!text){
      toast("no ingredients to download");
      return;
    }
    const blob = new Blob([text], {type:"text/plain"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = sanitizeFileName(r.title) + "_groceries.txt";
    a.click();
    URL.revokeObjectURL(url);
    toast("downloaded groceries");
  }

// ---- Paste Recipe (text -> structured recipe) ----
function openPasteModal(){
  const m = $("pasteModal");
  const t = $("pasteRecipeText");
  if(!m || !t) return;
  t.value = "";
  m.classList.add("show");
  m.setAttribute("aria-hidden","false");
  setTimeout(()=>t.focus(), 50);
}

function closePasteModal(){
  const m = $("pasteModal");
  if(!m) return;
  m.classList.remove("show");
  m.setAttribute("aria-hidden","true");
}

function looksLikeSubheading(line){
  const s = String(line||"").trim();
  if(!s) return false;
  if(s.length > 60) return false;
  if(/^\d+[\.\)]\s+/.test(s)) return false;
  // "For the sauce:" / "Sauce:" / "Optional:"
  return /:\s*$/.test(s);
}

function stripBullet(line){
  return String(line||"").replace(/^[-*•]\s+/, "").trim();
}

function stripHeadingLabel(line){
  // removes "Ingredients:", "Directions:", etc.
  return String(line||"").replace(/^\s*[A-Za-z ]+:\s*$/, "").trim();
}

function findSectionIndex(lines, re){
  for(let i=0;i<lines.length;i++){
    const s = String(lines[i]||"").trim().toLowerCase();
    if(re.test(s)) return i;
  }
  return -1;
}

function cleanIngredientsLines(lines){
  const out = [];
  for(const raw of (lines || [])){
    let s = String(raw||"").trim();
    if(!s) continue;

    // Skip obvious heading labels repeated inside the block
    if(/^(ingredients?)\s*:?\s*$/.test(s.toLowerCase())) continue;

    if(looksLikeSubheading(s)){
      out.push("## " + s.replace(/:\s*$/,"").trim());
      continue;
    }
    out.push(stripBullet(s));
  }
  return out.join("\n").trim();
}

function cleanDirectionsLines(lines){
  const out = [];
  for(const raw of (lines || [])){
    let s = String(raw||"").trim();
    if(!s) continue;

    if(/^(directions?|instructions?|method|steps?)\s*:?\s*$/.test(s.toLowerCase())) continue;

    if(looksLikeSubheading(s)){
      out.push("## " + s.replace(/:\s*$/,"").trim());
      continue;
    }

    s = stripBullet(s);
    s = stripLeadingStepNumber(s);
    out.push(s);
  }
  return out.join("\n").trim();
}

function parsePastedRecipeText(raw){
  let text = String(raw||"").replace(/\r/g,"").trim();
  text = text.replace(/\n{3,}/g, "\n\n");
  if(!text) return null;

  const lines = text.split("\n");

  // Optional "Title: ..."
  const titleLineMatch = text.match(/^\s*(?:title|recipe)\s*:\s*(.+)\s*$/im);
  let title = titleLineMatch ? String(titleLineMatch[1]||"").trim() : "";

  const iIng = findSectionIndex(lines, /^(ingredients?|what you(?:'|)ll need)\b/);
  const iDir = findSectionIndex(lines, /^(directions?|instructions?|method|steps?)\b/);
  const iNotes = findSectionIndex(lines, /^(notes?|tips?)\b/);

  // Title heuristics if not explicitly set
  if(!title){
    if(iIng > 0){
      const pre = lines.slice(0, iIng).map(s=>String(s||"").trim()).filter(Boolean);
      if(pre.length){
        title = pre[0].replace(/^#+\s*/,"").trim();
      }
    }else{
      const first = String(lines[0]||"").trim();
      if(first && first.length <= 90) title = first.replace(/^#+\s*/,"").trim();
    }
  }
  if(!title) title = "Imported Recipe";

  // Compute section slices
  const end = lines.length;

  const ingStart = (iIng >= 0) ? iIng + 1 : -1;
  const dirStart = (iDir >= 0) ? iDir + 1 : -1;
  const notesStart = (iNotes >= 0) ? iNotes + 1 : -1;

  const cut = (a,b)=> (a>=0 ? lines.slice(a, Math.max(a, b>=0?b:end)) : []);
  const nextAfter = (idx)=> {
    const candidates = [iIng, iDir, iNotes].filter(x=>x>=0 && x>idx);
    return candidates.length ? Math.min(...candidates) : -1;
  };

  let ingLines = [];
  let dirLines = [];
  let notesLines = [];

  if(iIng >= 0){
    ingLines = cut(ingStart, nextAfter(iIng));
  }
  if(iDir >= 0){
    dirLines = cut(dirStart, nextAfter(iDir));
  }
  if(iNotes >= 0){
    notesLines = cut(notesStart, -1);
  }

  // No explicit headings: try to infer split point at first numbered step
  if(iIng < 0 && iDir < 0){
    // remove title line from body if we used it
    let bodyLines = lines.slice(1);
    const stepIdx = bodyLines.findIndex(l => /^\s*\d+[\.\)]\s+/.test(String(l||"")));
    if(stepIdx >= 0){
      ingLines = bodyLines.slice(0, stepIdx);
      dirLines = bodyLines.slice(stepIdx);
    }else{
      // fallback: treat all as directions if it reads like paragraphs, else ingredients
      const manyShort = bodyLines.filter(l => String(l||"").trim().length > 0 && String(l||"").trim().length <= 60).length;
      const totalNonEmpty = bodyLines.filter(l => String(l||"").trim()).length;
      if(totalNonEmpty && manyShort / totalNonEmpty > 0.7){
        ingLines = bodyLines;
      }else{
        dirLines = bodyLines;
      }
    }
  }

  const ingredients = cleanIngredientsLines(ingLines);
  const directions = cleanDirectionsLines(dirLines);

  const notes = (notesLines || []).map(s=>String(s||"").trim()).filter(Boolean).join("\n").trim();

  return { title, ingredients, directions, notes };
}

function importRecipeFromPastedText(raw){
  const parsed = parsePastedRecipeText(raw);
  if(!parsed) return null;

  const t = Date.now();
  const r = {
    id: uid(),
    title: parsed.title || "Imported Recipe",
    cuisine: "",
    course: "",
    base: "",
    mainIngredient: "",
    appliances: [],
    timeMinutes: null,
    dishesCount: null,
    tags: [],
    cookedCount: 0,
    lastCookedAt: null,
    createdAt: t,
    updatedAt: t,
    imageUrl: "",
    imagePath: "",
    sourceUrl: "",
    servings: "",
    ingredients: parsed.ingredients || "",
    directions: parsed.directions || "",
    notes: parsed.notes || ""
  };

  state.recipes.unshift(r);
  saveLocal();
  refreshFilterOptions();
  renderGrid();
  openViewer(r.id);

  // Auto-open edit so you can clean up anything
  state.editOpen = true;
  $("editPanel").classList.add("show");
  $("editToggleBtn").textContent = "Close edit";
  fillEditForm(r);

  toast("pasted recipe imported");
  return r;
}


  /* Data import/export */
  function downloadJSON(){
    const blob=new Blob([JSON.stringify(state.recipes,null,2)], {type:"application/json"});
    const url=URL.createObjectURL(blob);
    const a=document.createElement("a");
    a.href=url; a.download="recipe-book-backup.json"; a.click();
    URL.revokeObjectURL(url);
    toast("downloaded JSON");
  }


  async function importJSON(file){
    const text = await file.text();
    const data = JSON.parse(text);
    if(!Array.isArray(data)) throw new Error("Invalid JSON");
    state.recipes = data;
    saveLocal();
    refreshFilterOptions();
    renderGrid();
    toast("imported");
  }

  window.__onAuthChange = async (user)=>{
  setGate(!user);

  // Signed out: keep data in memory/localStorage, but don't show it
  if(!user) return;

  // Signed in: run cloud sync immediately + render
  try{
    const cloud = await window.FB.loadAll();

    if(Array.isArray(cloud) && cloud.length){
      state.recipes = cloud;
      normalizeAllRecipesInPlace();
      saveLocal({ skipCloud:true });
    }

    refreshFilterOptions();
    rebuildTagCaches();
    refreshEditSuggestions();
    setCloudStatus();
    renderGrid();
    if(state.selectedId) renderViewer();
  }catch(e){
    console.warn("Auth-change cloud sync failed", e);
    toast("cloud offline");
  }
};


  async function init(){
    // Service worker (offline + faster repeat loads)
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker
        .register("sw.js", { scope: "./" })
        .catch(() => {});
}

// Fast start: local cache only (offline-capable after first signed-in load)
const local = loadLocal();
if(local){
  state.recipes = local;
  normalizeAllRecipesInPlace();
  toast("loaded local cache");
} else {
  state.recipes = [];
}
refreshFilterOptions();
rebuildTagCaches();
refreshEditSuggestions();




// Cloud sync (Firebase / Firestore)
await waitForFB();

if (window.FB && window.FB.enabled) {
  await (window._authInit || Promise.resolve(null));
  const user = window._getCurrentUser ? window._getCurrentUser() : null;

  setGate(!user);

// IMPORTANT: do NOT return here.
// We still need to finish init() so all event listeners/buttons are wired up.
// When the user signs in, __onAuthChange will load + render recipes.
if(!user){
  setCloudStatus();
  renderGrid(); // (won't be visible because gated, but keeps state sane)
} else {
  // Signed in now: proceed with cloud session below
}



  // Cloud-only session behavior:
  // - Signed out: keep local cache (for this device), but do not attempt cloud.
  // - Signed in: render immediately from local cache (offline-friendly), then pull cloud and subscribe.
  if (!user) {
    console.warn("Not signed in; skipping cloud sync.");
    toast("sign in to sync");
    setCloudStatus?.();

    // Keep whatever is already in state/local cache; do not wipe.
    refreshFilterOptions();
    rebuildTagCaches();
    refreshEditSuggestions();
    renderGrid();
    if (state.selectedId) renderViewer();

  } else {
    try {
      // 1) Instant render from local cache (works offline after first signed-in use on this device)
      const local = loadLocal();
      if (Array.isArray(local) && local.length > 0) {
        state.recipes = local;
        normalizeAllRecipesInPlace();
        refreshFilterOptions();
        rebuildTagCaches();
        refreshEditSuggestions();
        setCloudStatus();
        renderGrid();
        if (state.selectedId) renderViewer();
      }

      // 2) Cloud fetch (source of truth when it has data)
      const cloud = await window.FB.loadAll();

      if (Array.isArray(cloud) && cloud.length > 0) {
        state.recipes = cloud;
        normalizeAllRecipesInPlace();
        saveLocal({ skipCloud: true });
        refreshFilterOptions();
        rebuildTagCaches();
        refreshEditSuggestions();
        toast("synced from cloud");
      } else {
        // Cloud empty: do NOT wipe local
        console.warn("Cloud returned 0 recipes; keeping local cache.");
        toast("cloud empty (kept local)");
      }

      // 3) Live updates (ignore empty snapshots to avoid wiping local)
      if (window.FB.unsubscribe) window.FB.unsubscribe();
      window.FB.unsubscribe = window.FB.subscribe((list) => {
        if (state.editOpen) return;

        if (Array.isArray(list) && list.length > 0) {
          state.recipes = list;
          normalizeAllRecipesInPlace();
          saveLocal({ skipCloud: true });
          refreshFilterOptions();
          rebuildTagCaches();
          refreshEditSuggestions();
          setCloudStatus();
          renderGrid();
          if (state.selectedId) renderViewer();
        } else {
          console.warn("Cloud snapshot empty; ignoring to avoid wiping local.");
          setCloudStatus();
        }
      });

      setCloudStatus();
      renderGrid();
      if (state.selectedId) renderViewer();

    } catch (e) {
      console.warn("Firebase load/subscribe failed; using local cache.", e);
      toast("cloud offline");
      setCloudStatus?.();

      // Keep whatever is already in state/local cache; do not wipe.
      refreshFilterOptions();
      rebuildTagCaches();
      refreshEditSuggestions();
      renderGrid();
      if (state.selectedId) renderViewer();
    }
  }
}







    // Hook filters
    ["q","ingredientF","maxTime","cuisineF","equipmentF","dishTypeF","baseF","tagF","sort"].forEach(id=>{

      $(id).addEventListener("input", renderGrid);
      $(id).addEventListener("change", renderGrid);
    });

    function clearAllFilters(){
  $("q").value = "";
  $("cuisineF").value = "";
  $("equipmentF").value = "";
  $("dishTypeF").value = "";
  $("baseF").value = "";
  $("ingredientF").value = "";
  $("tagF").value = "";
  $("maxTime").value = "";

  renderGrid();
}


$("clearFiltersBtn").onclick = clearAllFilters;


    // Card size slider (inverted: right = bigger cards)
    $("size").addEventListener("input", applyCardSize);
    window.addEventListener("resize", applyCardSize);
    applyCardSize();


    $("newBtn").onclick = newRecipe;

    // Import menu actions
    $("pasteRecipeActionBtn").onclick = ()=>{
      openPasteModal();
      closeImportMenu();
    };

    $("importHtmlActionBtn").onclick = ()=>{
      const f = $("importHtmlFile");
      if(f){
        f.value = "";
        f.click();
      }
      closeImportMenu();
    };


$("pasteCancelBtn")?.addEventListener("click", closePasteModal);

$("pasteModal")?.addEventListener("pointerdown", (e)=>{
  // clicking the dark background closes; clicking the card does not
  if(e.target && e.target.id === "pasteModal") closePasteModal();
});

$("pasteImportBtn")?.addEventListener("click", ()=>{
  const raw = $("pasteRecipeText")?.value || "";
  if(!raw.trim()){
    alert("Paste a recipe first.");
    return;
  }
  try{
    importRecipeFromPastedText(raw);
    closePasteModal();
  }catch(e){
    console.warn(e);
    alert("Paste import failed. Try including headings like Ingredients: and Directions: to help parsing.");
  }
});

// Ctrl/Cmd+Enter to import
$("pasteRecipeText")?.addEventListener("keydown", (e)=>{
  const mac = /Mac|iPhone|iPad|iPod/i.test(navigator.platform);
  const mod = mac ? e.metaKey : e.ctrlKey;
  if(mod && e.key === "Enter"){
    e.preventDefault();
    $("pasteImportBtn")?.click();
  }
});


    $("backupBtn").onclick = ()=>{
      downloadJSON();
      closeAdvancedMenu();
    };


    function closeAdvancedMenu(){
  const d = document.getElementById("advancedMenu");
  if(d) d.open = false;
}
function closeImportMenu(){
  const d = document.getElementById("importMenu");
  if(d) d.open = false;
}

const advMenuEl = document.getElementById("advancedMenu");
const importMenuEl = document.getElementById("importMenu");

// Close menus when clicking/tapping outside
document.addEventListener("pointerdown", (e)=>{
  if(advMenuEl?.open && !advMenuEl.contains(e.target)) closeAdvancedMenu();
  if(importMenuEl?.open && !importMenuEl.contains(e.target)) closeImportMenu();
}, true);

// Close menus on Escape
window.addEventListener("keydown", (e)=>{
  if(e.key !== "Escape") return;
  if(advMenuEl?.open) closeAdvancedMenu();
  if(importMenuEl?.open) closeImportMenu();
});



$("restoreBtn").onclick = ()=>{
  $("importFile").value = "";
  $("importFile").click();
  closeAdvancedMenu();
};


$("importFile").addEventListener("change", async ()=>{
  const f = $("importFile").files?.[0];
  if(!f) return;
  try{
    await importJSON(f);
    toast("restored");
    // this will auto-sync to cloud (because saveLocal() calls scheduleFirebaseSync)
  }catch(e){
    console.warn(e);
    alert("Restore failed (bad JSON).");
  }
});

// ---- Import HTML recipe (from this app's "Download recipe" export) ----
function extractSectionLines(doc, headingText, listTag){
  const hs = Array.from(doc.querySelectorAll("h2"));
  const h2 = hs.find(x => (x.textContent || "").trim().toLowerCase() === headingText.toLowerCase());
  if(!h2) return [];

  const pad = h2.parentElement; // in your exported HTML, h2 sits inside .pad
  if(!pad) return [];

  const out = [];

  // Walk siblings after the H2: UL/OL and possible H3 section headers
  let node = h2.nextElementSibling;
  while(node){
    const tag = node.tagName?.toLowerCase();

    if(tag === "h2") break; // next major section
    if(tag === "h3"){
      const t = (node.textContent || "").trim();
      if(t) out.push("## " + t);
    }
    if(tag === (listTag || "ul")){
      const items = Array.from(node.querySelectorAll("li")).map(li => (li.textContent || "").trim()).filter(Boolean);
      out.push(...items);
    }

    node = node.nextElementSibling;
  }

  return out;
}

async function importRecipeFromHTMLFile(file){
  const html = await file.text();
  const doc = new DOMParser().parseFromString(html, "text/html");

  const title = (doc.querySelector("h1")?.textContent || file.name.replace(/\.html?$/i,"") || "Imported Recipe").trim();

  // Try to grab image + source (from your exported HTML)
  const imageUrl = (doc.querySelector("img")?.getAttribute("src") || "").trim();
  const sourceLink = Array.from(doc.querySelectorAll("a")).find(a => (a.textContent || "").toLowerCase().includes("http"));
  const sourceUrl = (sourceLink?.getAttribute("href") || "").trim();

  const ingLines = extractSectionLines(doc, "Ingredients", "ul");
  const dirLines = extractSectionLines(doc, "Directions", "ol");

  // Notes (optional)
  let notes = (doc.querySelector(".notes pre")?.textContent || "").trim();
  if(!notes){
    // fallback: any "Notes" section
    const h2Notes = Array.from(doc.querySelectorAll("h2")).find(x => (x.textContent||"").trim().toLowerCase() === "notes");
    if(h2Notes) notes = (h2Notes.parentElement?.querySelector("pre")?.textContent || "").trim();
  }

  const t = Date.now();
  const r = {
    id: uid(),
    title,
    cuisine: "",
    course: "",
    base: "",
    mainIngredient: "",
    appliances: [],
    timeMinutes: null,
    dishesCount: null,
    tags: [],
    cookedCount: 0,
    lastCookedAt: null,
    createdAt: t,
    updatedAt: t,
    imageUrl: imageUrl || "",
    imagePath: "",          // importing HTML doesn't bring a Firebase Storage path
    sourceUrl: sourceUrl || "",
    servings: "",
    ingredients: ingLines.join("\n"),
    directions: dirLines.join("\n"),
    notes: notes || ""
  };

  state.recipes.unshift(r);
  saveLocal();
  refreshFilterOptions();
  renderGrid();
  openViewer(r.id);
  toast("imported HTML");
}

// HTML file input wiring (button is handled above in Import menu actions)
const importHtmlFile = $("importHtmlFile");
if(importHtmlFile){
  importHtmlFile.addEventListener("change", async ()=>{
    const f = importHtmlFile.files?.[0];
    if(!f) return;
    try{
      await importRecipeFromHTMLFile(f);
    }catch(e){
      console.warn(e);
      alert("HTML import failed. This importer currently expects the HTML exported by your own app (Download recipe).");
    }finally{
      importHtmlFile.value = "";
    }
  });
}



$("signOutBtn").onclick = async ()=>{
  if(!confirm("Sign out on this device? You can sign back in anytime.")) return;
  try{
    await (window.AUTH?.signOut?.());
    toast("signed out");
  }catch(e){
    console.warn(e);
    toast("sign out failed");
  }
  closeAdvancedMenu();
};

$("pushCloudBtn").onclick = async ()=>{
  const user = window._getCurrentUser ? window._getCurrentUser() : null;
  if(!user){ alert("Sign in first."); return; }

  const msg =
`Push THIS device's copy to the cloud?

Use this ONLY for recovery / intentional overwrite:
• Example: your cloud got wiped or you're restoring from a backup
• It overwrites the cloud copy to match THIS device

Normal edits auto-sync.`;

  if(!confirm(msg)) return;

  try{
    await window.FB.syncAll(state.recipes);
    toast("pushed to cloud");
  }catch(e){
    console.warn(e);
    toast("push failed");
  }

  closeAdvancedMenu();
};




    // Viewer buttons
    $("overlay").onclick = closeViewer;
    $("backBtn").onclick = closeViewer;
    $("editToggleBtn").onclick = toggleEdit;
    $("cancelEditBtn").onclick = toggleEdit;
    $("saveEditBtn").onclick = saveEdit;

    // --- Image upload (Firebase Storage) ---
    const addBtn = $("addImageBtn");
    const rmBtn  = $("removeImageBtn");
    const fileIn = $("imageFileInput");

    if(addBtn && fileIn){
      addBtn.onclick = ()=> fileIn.click();

      fileIn.onchange = async ()=>{
        const file = fileIn.files && fileIn.files[0];
        if(!file) return;

        const r = getSelected();
        if(!r) return;

        // Basic guard: huge photos can be slow (you can add compression later)
        const maxMB = 12;
        if(file.size > maxMB * 1024 * 1024){
          alert(`That photo is bigger than ${maxMB}MB. Choose a smaller one (or we’ll add compression).`);
          fileIn.value = "";
          return;
        }

        try{
          addBtn.disabled = true;
          addBtn.textContent = "Uploading…";

          const prevPath = $("eImagePath") ? $("eImagePath").value.trim() : (r.imagePath || "");

// Compress before upload (fast + cheap)
const compressed = await compressImageFile(file, 1600, 0.72);
const out = await window.FB.uploadRecipeImage({
  recipeId: r.id,
  file: compressed,
  filenameHint: file.name
});


          // Save into edit fields immediately
          $("eImageUrl").value = out.url;
          if($("eImagePath")) $("eImagePath").value = out.path;

          setEditImagePreview(out.url);

          // OPTIONAL BUT RECOMMENDED: delete old file after new upload succeeds
          if(prevPath && prevPath !== out.path){
            try{ await window.FB.deleteRecipeImage(prevPath); }catch(e){ console.warn("Old image delete failed:", e); }
          }

          // Update recipe immediately + sync (so you don’t forget to hit Save)
          const idx = state.recipes.findIndex(x=>x.id===r.id);
          if(idx >= 0){
            state.recipes[idx].imageUrl = out.url;
            state.recipes[idx].imagePath = out.path;
            state.recipes[idx].updatedAt = Date.now();
            saveLocal();
            renderGrid();
            renderViewer();
            toast("image saved");
          }
        }catch(e){
          console.error(e);
          alert("Upload failed. Are you signed in and online?");
        }finally{
          addBtn.disabled = false;
          addBtn.textContent = "Add / Change image";
          fileIn.value = "";
        }
      };
    }

    if(rmBtn){
      rmBtn.onclick = async ()=>{
        const r = getSelected();
        if(!r) return;

        const path = $("eImagePath") ? $("eImagePath").value.trim() : (r.imagePath || "");
        if(!path && !($("eImageUrl")?.value||"").trim()){
          setEditImagePreview("");
          return;
        }

        if(!confirm("Remove this recipe image?")) return;

        try{
          rmBtn.disabled = true;
          rmBtn.textContent = "Removing…";

          if(path){
            try{ await window.FB.deleteRecipeImage(path); }catch(e){ console.warn("Delete failed:", e); }
          }

          $("eImageUrl").value = "";
          if($("eImagePath")) $("eImagePath").value = "";
          setEditImagePreview("");

          const idx = state.recipes.findIndex(x=>x.id===r.id);
          if(idx >= 0){
            state.recipes[idx].imageUrl = "";
            state.recipes[idx].imagePath = "";
            state.recipes[idx].updatedAt = Date.now();
            saveLocal();
            renderGrid();
            renderViewer();
            toast("image removed");
          }
        }finally{
          rmBtn.disabled = false;
          rmBtn.textContent = "Remove image";
        }
      };
    }

// Live-filter suggestions as you type in edit fields
["eCuisine","eDishType","eBase","eIngredient","eEquipment","eTags"].forEach(id=>{
  const el = $(id);
  if(!el) return;
  el.addEventListener("input", refreshEditSuggestions);
  el.addEventListener("focus", refreshEditSuggestions);
});


    $("markCookedBtn").onclick = markCooked;
    $("deleteBtn").onclick = deleteRecipe;
    $("downloadOneBtn").onclick = downloadOne;
    $("printBtn").onclick = printCard;
    $("copyGroceriesBtn").onclick = copyGroceries;
    $("downloadGroceriesBtn").onclick = downloadGroceriesTxt;

    // Master "check all" checkbox
    const master = $("toggleAllIngCb");
    if(master){
      master.onchange = ()=> setAllIngredientChecks(master.checked);
    }


        // Cook mode
    setCookMode(localStorage.getItem(COOKMODE_KEY) === "1");
    $("cookModeBtn").onclick = ()=>{
      setCookMode(!cookModeEnabled());
    };


    // Scale controls
    $("scaleDown").onclick = ()=>{
      const r = getSelected(); if(!r) return;

      if(state.baseServings){
        const el = $("scaleServingsTarget");
        const v = Math.max(0.5, (Number(el.value) || state.baseServings) - 1);
        el.value = String(v);
      } else {
        state.scaleFactor = Math.max(0.125, state.scaleFactor / 2);
      }

      updateScaleUI();
      renderIngredients(r, state.scaleFactor);
      persistCurrentScale();
    };

    $("scaleUp").onclick = ()=>{
      const r = getSelected(); if(!r) return;

      if(state.baseServings){
        const el = $("scaleServingsTarget");
        const v = (Number(el.value) || state.baseServings) + 1;
        el.value = String(v);
      } else {
        state.scaleFactor = Math.min(16, state.scaleFactor * 2);
      }

      updateScaleUI();
      renderIngredients(r, state.scaleFactor);
      persistCurrentScale();
    };

    $("scaleReset").onclick = ()=>{
      const r = getSelected(); if(!r) return;

      state.scaleFactor = 1;
      if(state.baseServings){
        $("scaleServingsTarget").value = String(state.baseServings);
      }

      updateScaleUI();
      renderIngredients(r, state.scaleFactor);
      persistCurrentScale();
    };

    $("scaleServingsTarget").addEventListener("input", ()=>{
      const r = getSelected(); if(!r) return;
      if(!state.baseServings) return;

      updateScaleUI();
      renderIngredients(r, state.scaleFactor);
      persistCurrentScale();
  });


    // Snackbar undo
    $("snackUndo").onclick = () => { if(undoFn) undoFn(); hideSnack(); };

    // ESC to close viewer on desktop
    window.addEventListener("keydown", (e)=>{
      if(e.key==="Escape" && $("viewer").classList.contains("show")){
        closeViewer();
      }
    });

    setCloudStatus();
    renderGrid();
    refreshEditSuggestions();

  }


  init();
</script>
</body>
</html>
